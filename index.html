<!DOCTYPE html>
<html lang="ZH">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Turkey Quest EP1</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (React 18 - Stable for local file execution) -->
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.3.1/umd/react.development.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.3.1/umd/react-dom.development.js"></script>
    
    <!-- Babel for in-browser JSX compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind Config -->
    <script>
      tailwind.config = {
        theme: {
          extend: {
            animation: {
              'fade-in': 'fadeIn 0.5s ease-out',
              'fade-in-up': 'fadeInUp 0.3s ease-out',
              'bounce-slight': 'bounceSlight 2s infinite',
              'pulse': 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
              'victory-pop': 'victoryPop 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards',
              'pulse-glow': 'pulseGlow 2s ease-in-out infinite',
            },
            keyframes: {
              fadeIn: {
                '0%': { opacity: '0' },
                '100%': { opacity: '1' },
              },
              fadeInUp: {
                '0%': { opacity: '0', transform: 'translateY(10px)' },
                '100%': { opacity: '1' },
              },
              bounceSlight: {
                '0%, 100%': { transform: 'translateY(-2%)' },
                '50%': { transform: 'translateY(0)' },
              },
              victoryPop: {
                '0%': { opacity: '0', transform: 'scale(0.5) translateY(20px)' },
                '100%': { opacity: '1', transform: 'scale(1) translateY(0)' },
              },
              pulseGlow: {
                '0%, 100%': { filter: 'drop-shadow(0 0 5px rgba(234, 179, 8, 0.3))', transform: 'scale(1)' },
                '50%': { filter: 'drop-shadow(0 0 20px rgba(234, 179, 8, 0.8))', transform: 'scale(1.05)' },
              }
            }
          }
        }
      }
    </script>

    <style>
      @import url('https://fonts.googleapis.com/css2?family=VT323&family=DotGothic16&display=swap');
      
      html, body, #root {
        height: 100%;
        margin: 0;
        padding: 0;
      }

      body {
        background-color: #000;
        color: white;
        font-family: 'DotGothic16', sans-serif;
        overflow: hidden;
        touch-action: none;
      }
      
      /* Scanlines effect */
      .scanlines {
        background: linear-gradient(
          to bottom,
          rgba(255,255,255,0),
          rgba(255,255,255,0) 50%,
          rgba(0,0,0,0.1) 50%,
          rgba(0,0,0,0.1)
        );
        background-size: 100% 4px;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 50;
      }

      ::-webkit-scrollbar { width: 8px; }
      ::-webkit-scrollbar-track { background: #000; }
      ::-webkit-scrollbar-thumb { background: #333; border: 1px solid #000; border-radius: 4px; }
      
      img { image-rendering: pixelated; }

      .font-vt323 { font-family: 'VT323', monospace; }
      .pixelated { image-rendering: pixelated; }
      @keyframes bounce-slight { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }
      .animate-bounce-slight { animation: bounce-slight 2s infinite; }
      @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
      .animate-shake { animation: shake 0.3s ease-in-out; }
      @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
      .animate-float { animation: float 3s ease-in-out infinite; }
      .animate-fade-in { animation: fadeIn 0.5s ease-out; }
      @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
      .animate-fade-in-up { animation: fadeInUp 0.3s ease-out; }
      @keyframes fadeInUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
      
      .text-shadow-retro {
        text-shadow: 2px 2px 0px #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
      }
    </style>

    <!-- Initialize Global Environment Shim -->
    <script>
      window.process = { env: { API_KEY: '' } };
    </script>

    <!-- Import Map for Google GenAI Only -->
    <script type="importmap">
    {
      "imports": {
        "@google/genai": "https://esm.run/@google/genai"
      }
    }
    </script>

    <!-- Load Google GenAI Library -->
    <script type="module">
      import { GoogleGenAI, Type } from '@google/genai';
      window.GoogleGenAI = GoogleGenAI;
      window.GenAIType = Type;
    </script>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div id="root"></div>

    <!-- ========================================== -->
    <!-- 1. Game Data & Constants (Standard JS)     -->
    <!-- ========================================== -->
    <script>
      // Expose constants to global window object
      window.Language = {
        EN: 'EN',
        ZH: 'ZH'
      };

      window.GameState = {
        TITLE: 'TITLE',
        MAP: 'MAP',
        TOWN: 'TOWN',
        DUNGEON: 'DUNGEON',
        BATTLE: 'BATTLE',
        NAME_INPUT: 'NAME_INPUT'
      };

      window.BattleState = {
        LOADING: 'LOADING',
        PLAYER_INPUT: 'PLAYER_INPUT',
        PROCESSING: 'PROCESSING',
        VICTORY: 'VICTORY',
        DEFEAT: 'DEFEAT'
      };

      window.GAME_VERSION = "v1.5.0";

      window.TRANSLATIONS = {
        [window.Language.EN]: {
          worldMapName: "Prince Edward Island",
          loading: "Summoning Monster...",
          title: "TURKEY QUEST",
          start: "Start Adventure",
          continue: "Continue",
          credits: "Credits",
          hp: "HP",
          mp: "MP",
          lvl: "LVL",
          atk: "ATK",
          def: "DEF",
          potions: "Potions",
          reincarnationLabel: "Rank",
          quickHeal: "Quick Heal",
          quickHealMagic: "Mag (3MP)",
          quickHealPotion: "Potion (1)",
          about: {
            title: "About Turkey Quest",
            plot: "Plot: In a world dominated by mutant turkeys, a hero rises to reclaim Prince Edward Island. Guided by the spirit of Anne, you must defeat the poultry overlords.",
            gameplay: "Gameplay: AI make the monster turkeys. Turn-based RPG. Explore 3 towns, clear dungeons, collect loot, and reincarnate to get stronger. Supports Touch & Mouse.",
            author: "Author: HSJ David Ho",
            email: "Email: ntcudavid@gmail.com",
            close: "Close"
          },
          apiKeyModal: {
            title: "Configure API Key",
            explanation: "To enable AI monster generation, please enter your API Key. It is only recorded locally on your device and will not be used for any other purpose.",
            placeholder: "Paste Google Gemini API Key here",
            hint: "Your key is stored locally in your browser. It is not sent to any other server.",
            save: "Save Key",
            clear: "Clear Key",
            close: "Close",
            savedMsg: "Key Saved!",
            clearedMsg: "Key Cleared. Using Fallback.",
            getApiKeyLink: "Get API Key"
          },
          naming: {
            title: "Name Your Hero",
            placeholder: "Enter Name",
            hint: "Max 10 letters",
            confirm: "Start Journey",
            defaultName: "Anne"
          },
          saveLoad: {
            saveTitle: "Save Adventure",
            loadTitle: "Load Adventure",
            emptySlot: "Empty Slot",
            saveBtn: "Save",
            backBtn: "Back",
            savedMsg: "Game Saved!",
            loadedMsg: "Game Loaded!",
            autoSave: "AUTO-SAVE",
            autoSavedLog: "[SYSTEM] Progress Auto-Saved.",
            returnTitle: "Return Home",
            returningMsg: "[SYSTEM] Auto-saved. Returning Home..."
          },
          cmdPhysical: "Physical",
          cmdMagAtk: "Mag. Atk",
          cmdMagHeal: "Mag. Heal",
          cmdItem: "Potion Heal",
          cmdFlee: "Run",
          enemyAppears: (name) => `A wild ${name} gobbles loudly!`,
          playerAttack: (dmg) => `Sword Strike! ${dmg.toLocaleString()} damage!`,
          playerMagAtk: (dmg) => `Fireball! ${dmg.toLocaleString()} burn damage!`,
          enemyAttack: (name, dmg) => `${name} pecks! Hero takes ${dmg.toLocaleString()} damage!`,
          win: (exp, gold) => `Victory! Plucked ${exp.toLocaleString()} EXP and ${gold.toLocaleString()} Gold.`,
          loot: {
            found: (item) => `Found ${item}!`,
            equip: (stat, val) => `Equipped! ${stat} increased by ${val}.`,
            learn: (stat, val) => `Ancient Recipe! ${stat} +${val}.`
          },
          lose: "Overwhelmed by the flock...",
          runSuccess: "Escaped to fight another day!",
          runFail: "The Turkey blocks the way!",
          heal: (amt) => `Healing Light! Recovered ${amt.toLocaleString()} HP.`,
          itemUsed: () => `Hero used Potion Heal.`,
          noItem: "No Potions left!",
          noMp: "Not enough MP!",
          locations: {
            forest: "Feather Woods",
            mountain: "Beak Peaks",
            volcano: "Roaster Dungeon",
            castle: "Thanksgiving Keep"
          },
          mapActions: {
            enterTown: "Enter Town",
            enterDungeon: "Enter Dungeon"
          },
          town: {
            welcome: "Welcome to Thanksgiving Keep.",
            enterShop: "Press ENTER to visit",
            exitTown: "Exit Town",
            shops: {
              guild: "Adventurer's Guild",
              weapon: "Blacksmith",
              armor: "Armory",
              item: "General Store",
              magic: "Wizard's Tower"
            },
            actions: {
              rest: (cost) => `Rest & Heal (${cost.toLocaleString()}G)`,
              buyWeapon: (cost) => `Sharpen Sword (+3 ATK) - ${cost.toLocaleString()}G`,
              buyArmor: (cost) => `Reinforce Shield (+3 DEF) - ${cost.toLocaleString()}G`,
              buyPotion: (cost) => `Buy Red Potion - ${cost.toLocaleString()}G`,
              buyMagic: (cost) => `Study Scrolls (+5 MaxMP) - ${cost.toLocaleString()}G`,
              leave: "Leave Shop"
            },
            notEnoughGold: "Not enough Gold!",
            restored: "Fully restored!",
            bought: "Transaction complete!"
          },
          dungeon: {
            title: "Exploring...",
            floor: (f) => `Dungeon B${f}F`,
            forward: "Move Forward",
            goDeeper: "Descend to B2F",
            returnSurface: "Return to Surface",
            search: "Look Around",
            leave: "Escape Dungeon",
            nothing: "Just feathers and dust...",
            foundGold: (amt) => `Found a treasure chest with ${amt.toLocaleString()} Gold!`,
            encounter: "GOBBLE GOBBLE! (Enemy approaches)",
            bossEncounter: "DANGER! A massive presence approaches!",
            floorCleared: "The Floor Guardian is defeated!",
            sceneUnlocked: "A new area has been unlocked!",
            reincarnationMsg: (n) => `Reincarnation successful. Rank: ${n}.`
          },
          reincarnationModal: {
            title: "The Cycle of Rebirth",
            message: (n) => `Congratulations! You have defeated the ultimate evil of Prince Edward Island.\n\nYour spirit will now transmigrate to a new timeline.\n\nYou retain your Level, Gold, and Equipment.\nMonsters will become stronger in the next cycle.\n\nRank: ${n}`,
            bonus: "REWARD: ATK +10, DEF +10",
            confirm: "Accept Reincarnation"
          },
          scenes: {
            avonlea: "1. Avonlea",
            charlottetown: "3. Charlottetown",
            cavendish: "2. Cavendish",
            travelTo: (place) => `Travel to ${place}`,
            locked: "Area Locked (Clear Previous Dungeon)"
          },
          facilityHints: {
              house: "Green Gables: Rest here to recover HP/MP over time.",
              school: "Avonlea School: Study hard to earn Scholarship (Gold) over time.",
              academy: "Queen's Academy: Advanced training grants Potions over time."
          }
        },
        [window.Language.ZH]: {
          worldMapName: "æ„›å¾·è¯ç‹å­å³¶",
          loading: "ç•°ç•Œé­”ç‰©å¬å–šä¸­...",
          title: "å‹‡è€…é¬¥ç«é›",
          start: "é–‹å•Ÿå†’éšªä¹‹æ›¸",
          continue: "è®€å–é€²åº¦",
          credits: "è£½ä½œåœ˜éšŠ",
          hp: "ç”Ÿå‘½",
          mp: "é­”åŠ›",
          lvl: "ç­‰ç´š",
          atk: "æ”»æ“Š",
          def: "é˜²ç¦¦",
          potions: "è—¥æ°´",
          reincarnationLabel: "è½‰ç”Ÿ",
          quickHeal: "å¿«é€Ÿæ²»ç™‚",
          quickHealMagic: "é­”æ³• (3MP)",
          quickHealPotion: "è—¥æ°´ (1)",
          about: {
            title: "é—œæ–¼ å‹‡è€…é¬¥ç«é›",
            plot: "åŠ‡æƒ…ï¼šåœ¨é€™å€‹è¢«è®Šç•°ç«é›çµ±æ²»çš„ä¸–ç•Œï¼Œå‹‡è€…æŒºèº«è€Œå‡ºï¼Œèª“è¨€å¥ªå›æ„›å¾·è¯ç‹å­å³¶ã€‚åœ¨æ¸…ç§€ä½³äººå®‰å¦®çš„æŒ‡å¼•ä¸‹ï¼Œæ“Šæ•—ç«é›éœ¸ä¸»ï¼Œè®“äººé¡é‡ç²è‡ªç”±ã€‚",
            gameplay: "ç©æ³•ï¼šAIå³æ™‚èå…¥éŠæˆ²æ€ªç‰©å‰µä½œï¼Œç¶“å…¸å›åˆåˆ¶ RPGã€‚æ¢ç´¢ä¸‰å€‹åŸé®ï¼Œæ”»ç•¥é›™å±¤åœ°ä¸‹åŸï¼Œæ”¶é›†ç¥è£èˆ‡é­”æ³•æ›¸ã€‚é€éç„¡é™è½‰ç”Ÿæ©Ÿåˆ¶ï¼Œä¸æ–·çªç ´æ•¸å€¼æ¥µé™ã€‚",
            author: "ä½œè€…ï¼šä¿¡ David Ho",
            email: "ä¿¡ç®±ï¼šntcudavid@gmail.com",
            close: "é—œé–‰"
          },
          apiKeyModal: {
            title: "è¨­å®š API Key",
            explanation: "è‹¥è¦ä½¿ç”¨AIè‡ªå‹•ç”Ÿæˆæ€ªç‰©åŠŸèƒ½ï¼Œè«‹è¼¸å…¥API Keyï¼Œåƒ…åœ¨æ‚¨çš„æœ¬åœ°ç«¯è¨˜éŒ„ï¼Œä¸æœƒæœ‰å…¶ä»–è¨˜éŒ„èˆ‡ç”¨é€”ã€‚",
            placeholder: "åœ¨æ­¤è²¼ä¸Šæ‚¨çš„ Google Gemini API Key",
            hint: "æ‚¨çš„ Key åƒ…å„²å­˜åœ¨æ‚¨çš„æœ¬åœ°ç€è¦½å™¨ï¼Œä¸æœƒä¸Šå‚³è‡³å…¶ä»–ä¼ºæœå™¨ã€‚",
            save: "å„²å­˜ Key",
            clear: "æ¸…é™¤ Key",
            close: "é—œé–‰",
            savedMsg: "Key å·²å„²å­˜ï¼",
            clearedMsg: "Key å·²æ¸…é™¤ï¼Œå°‡ä½¿ç”¨é è¨­è¨­å®šã€‚",
            getApiKeyLink: "å‰å¾€å–å¾— API Key"
          },
          naming: {
            title: "è«‹è¼¸å…¥å‹‡è€…å§“å",
            placeholder: "è¼¸å…¥å§“å",
            hint: "æœ€å¤š5å€‹ä¸­æ–‡å­—æˆ–10å€‹è‹±æ–‡å­—",
            confirm: "é–‹å§‹æ—…ç¨‹",
            defaultName: "Anne"
          },
          saveLoad: {
            saveTitle: "å„²å­˜å†’éšª",
            loadTitle: "è®€å–å†’éšª",
            emptySlot: "ç©ºç™½è¨˜éŒ„",
            saveBtn: "è¨˜éŒ„",
            backBtn: "è¿”å›",
            savedMsg: "è¨˜éŒ„å®Œæˆï¼",
            loadedMsg: "è®€å–å®Œæˆï¼",
            autoSave: "ç³»çµ±è‡ªå‹•å­˜æª”",
            autoSavedLog: "[ç³»çµ±] é€²åº¦å·²è‡ªå‹•ä¿å­˜ã€‚",
            returnTitle: "å›é¦–é ",
            returningMsg: "[ç³»çµ±] é€²åº¦å·²è‡ªå‹•ä¿å­˜ï¼Œæ­£åœ¨è¿”å›é¦–é ..."
          },
          cmdPhysical: "ç‰©ç†æ”»æ“Š",
          cmdMagAtk: "é­”æ³•æ”»æ“Š",
          cmdMagHeal: "é­”æ³•æ²»ç™’",
          cmdItem: "è—¥æ°´æ²»ç™’",
          cmdFlee: "è½‰èº«é€ƒè·‘",
          enemyAppears: (name) => `å…‡çŒ›çš„ ${name} å‡ºç¾äº†ï¼`,
          playerAttack: (dmg) => `å‹‡è€…çš„æ–¬æ“Šï¼çµ¦äºˆç«é› ${dmg.toLocaleString()} é»å‚·å®³ï¼`,
          playerMagAtk: (dmg) => `å‹‡è€…æ–½æ”¾çˆ†ç‚è¡“ï¼é€ æˆ ${dmg.toLocaleString()} é»ç‡ƒç‡’å‚·å®³ï¼`,
          enemyAttack: (name, dmg) => `${name} çš„æ”»æ“Šï¼å‹‡è€…å—åˆ°äº† ${dmg.toLocaleString()} é»å‚·å®³ï¼`,
          win: (exp, gold) => `å‹åˆ©ï¼ç²å¾— ${exp.toLocaleString()} ç¶“é©—å€¼èˆ‡ ${gold.toLocaleString()} é‡‘å¹£ã€‚`,
          loot: {
            found: (item) => `ç™¼ç¾äº† ${item}ï¼`,
            equip: (stat, val) => `è£å‚™ç¢ºèªï¼${stat} æå‡äº† ${val} é»ã€‚`,
            learn: (stat, val) => `ç¿’å¾—é£Ÿè­œï¼${stat} å¢åŠ äº† ${val} é»ã€‚`
          },
          lose: "å‹‡è€…è¢«ç«é›ç¾¤æ·¹æ²’äº†......",
          runSuccess: "å‹‡è€…æˆåŠŸé€ƒèµ°äº†ï¼",
          runFail: "è¢«ç¿…è†€æ“‹ä½äº†ï¼ç„¡æ³•é€ƒè·‘ï¼",
          heal: (amt) => `å‹‡è€…æ–½æ”¾è–å…‰è¡“ï¼æ¢å¾©äº† ${amt.toLocaleString()} é»ç”Ÿå‘½ã€‚`,
          itemUsed: () => `å‹‡è€…ä½¿ç”¨äº†è—¥æ°´æ²»ç™’ã€‚`,
          noItem: "æ²’æœ‰è—¥æ°´äº†ï¼",
          noMp: "MP ä¸è¶³ï¼",
          locations: {
            forest: "è½ç¾½ä¹‹æ£®",
            mountain: "å°–å–™å±±è„ˆ",
            volcano: "çƒ¤çˆåœ°ä¸‹åŸ",
            castle: "æ„Ÿæ©ç¯€å ¡å£˜"
          },
          mapActions: {
            enterTown: "é€²å…¥åŸé®",
            enterDungeon: "é€²å…¥åœ°ä¸‹åŸ"
          },
          town: {
            welcome: "æ­¡è¿ä¾†åˆ°æ„Ÿæ©ç¯€å ¡å£˜ã€‚",
            enterShop: "æŒ‰ ENTER é€²å…¥è¨­æ–½",
            exitTown: "é›¢é–‹åŸé®",
            shops: {
              guild: "å†’éšªè€…å…¬æœƒ",
              weapon: "æ­¦å™¨é›é€ å±‹",
              armor: "çš‡å®¶é˜²å…·åº—",
              item: "é›œè²¨åº—",
              magic: "å¤§é­”å°å£«ä¹‹å¡”"
            },
            actions: {
              rest: (cost) => `ä¼‘æ¯å›å¾© (${cost.toLocaleString()}G)`,
              buyWeapon: (cost) => `å¼·åŒ–æ­¦å™¨ (+3 æ”»æ“Š) - ${cost.toLocaleString()}G`,
              buyArmor: (cost) => `å¼·åŒ–é˜²å…· (+3 é˜²ç¦¦) - ${cost.toLocaleString()}G`,
              buyPotion: (cost) => `è³¼è²·ç´…è‰²è—¥æ°´ - ${cost.toLocaleString()}G`,
              buyMagic: (cost) => `ç ”è®€å¤å· (+5 MaxMP) - ${cost.toLocaleString()}G`,
              leave: "é›¢é–‹è¨­æ–½"
            },
            notEnoughGold: "é‡‘å¹£ä¸è¶³ï¼",
            restored: "é«”åŠ›å®Œå…¨æ¢å¾©äº†ï¼",
            bought: "äº¤æ˜“å®Œæˆï¼"
          },
          dungeon: {
            title: "æ¢ç´¢ä¸­...",
            floor: (f) => `åœ°ä¸‹ ${f} å±¤`,
            forward: "å‘å‰æ¢ç´¢",
            goDeeper: "é€²å…¥åœ°ä¸‹ 2 å±¤",
            returnSurface: "è¿”å›åœ°é¢",
            search: "èª¿æŸ¥å‘¨é‚Š",
            leave: "é€ƒé›¢åœ°ä¸‹åŸ",
            nothing: "é€™è£¡åªæœ‰é›æ¯›......",
            foundGold: (amt) => `ç™¼ç¾äº†å¯¶ç®±ï¼ç²å¾— ${amt.toLocaleString()} é‡‘å¹£ã€‚`,
            encounter: "è½åˆ°äº†å·¨å¤§çš„å’•å’•è²ï¼",
            bossEncounter: "è­¦å‘Šï¼æ„Ÿè¦ºåˆ°äº†å·¨å¤§çš„æ®ºæ°£ï¼",
            floorCleared: "è©²å±¤çš„å®ˆè­·è€…å·²è¢«æ“Šæ•—ï¼",
            sceneUnlocked: "é€šå¾€æ–°å€åŸŸçš„é“è·¯é–‹å•Ÿäº†ï¼",
            reincarnationMsg: (n) => `æ­å–œæˆ°å‹æœ€çµ‚é ­ç›®ï¼ç³»çµ±å°‡å¹«æ‚¨è½‰ç”Ÿã€‚æ¯æ¬¡è½‰ç”Ÿå¯æå‡ æ”»æ“Š+10ï¼Œé˜²ç¦¦+10ã€‚æ‚¨ç›®å‰è½‰ç”Ÿæ¬¡æ•¸ç‚º ${n}æ¬¡ã€‚`
          },
          reincarnationModal: {
            title: "å‚³èªªçš„çµ‚çµèˆ‡é–‹å§‹",
            message: (n) => `æ­å–œæˆ°å‹æ„›å¾·è¯ç‹å­å³¶çš„æœ€çµ‚éœ¸ä¸»ï¼\n\nä½œç‚ºçå‹µï¼Œæ‚¨çš„éˆé­‚å°‡ç¶“æ­·è½‰ç”Ÿï¼Œ\nç¹¼æ‰¿ç¾æœ‰çš„ç­‰ç´šã€é‡‘å¹£èˆ‡è£å‚™ï¼Œ\nä¸¦å‰å¾€æ–°çš„è¼ªè¿´ã€‚\n\nä¸‹å€‹è¼ªè¿´çš„æ€ªç‰©å°‡æœƒæ›´å¼·å¤§ï¼Œ\nè«‹æº–å‚™å¥½è¿æ¥æŒ‘æˆ°ã€‚\n\nç›®å‰è½‰ç”Ÿæ¬¡æ•¸ï¼š${n}`,
            bonus: "è½‰ç”Ÿçå‹µï¼šæ”»æ“ŠåŠ› +10ï¼Œé˜²ç¦¦åŠ› +10",
            confirm: "æ¥å—è½‰ç”Ÿï¼Œé–‹å•Ÿæ–°å†’éšª"
          },
          scenes: {
            avonlea: "1. è‰¾å‡¡é‡Œ (Avonlea)",
            charlottetown: "3. å¤æ´›ç‰¹æ•¦ (Charlottetown)",
            cavendish: "2. å¡æ–‡è¿ªä»€ (Cavendish)",
            travelTo: (place) => `å‰å¾€ ${place}`,
            locked: "å€åŸŸæœªè§£é– (éœ€é€šé—œå‰ä¸€åœ°åŸ)"
          },
          facilityHints: {
              house: "ç¶ å±±èŠï¼šåœ¨æ­¤é§ç•™å¯æŒçºŒæ¢å¾© HP/MPã€‚",
              school: "è‰¾å‡¡é‡Œå­¸æ ¡ï¼šåœ¨æ­¤é§ç•™å¯ç²å¾—çå­¸é‡‘ (é‡‘å¹£)ã€‚",
              academy: "å¥³ç‹å­¸é™¢ï¼šæ¥å—é«˜ç­‰æ•™è‚²å¯ç²å¾— è—¥æ°´ è£œçµ¦ã€‚"
          }
        }
      };

      window.INITIAL_PLAYER = {
        name: "Anne", 
        level: 1,
        hp: 250,      
        maxHp: 250,   
        mp: 50,       
        maxMp: 50,    
        exp: 0,
        gold: 0,
        potions: 0,
        equipmentAtk: 0,
        equipmentDef: 0,
        reincarnationCount: 0 
      };

      window.GOD_MODE_PLAYER = {
        name: "Hero (God)",
        level: 99,
        hp: 10000,
        maxHp: 10000,
        mp: 10000,
        maxMp: 10000,
        exp: 0,
        gold: 1000000,
        potions: 100,
        equipmentAtk: 500,
        equipmentDef: 0,
        reincarnationCount: 10
      };

      window.PLAYER_SPRITE_URL = "https://api.dicebear.com/9.x/adventurer/svg?seed=Zoey&hair=long02";
      window.POTION_ICON_URL = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' fill='none'><path d='M35 25 h30 v10 h-10 v15 h15 a5 5 0 0 1 5 5 v30 a10 10 0 0 1 -10 10 h-40 a10 10 0 0 1 -10 -10 v-30 a5 5 0 0 1 5 -5 h15 v-15 h-10 z' fill='%23e11d48' stroke='%23fff' stroke-width='2'/><path d='M40 20 h20 v5 h-20 z' fill='%239f1239'/></svg>";
      window.MONSTER_FALLBACK_URL = "https://cdn-icons-png.flaticon.com/512/1895/1895685.png"; 

      window.LOCATION_IMAGES = {
        forest: "https://images.unsplash.com/photo-1448375240586-dfd8d395ea6c?q=80&w=1200&auto=format&fit=crop",
        mountain: "https://images.unsplash.com/photo-1464822759023-fed622ff2c3b?q=80&w=1200&auto=format&fit=crop",
        volcano: "https://images.unsplash.com/photo-1462331940025-496dfbfc7564?q=80&w=1200&auto=format&fit=crop",
        castle: "https://images.unsplash.com/photo-1519074069444-1ba4fff66d16?q=80&w=1200&auto=format&fit=crop"
      };

      window.SHOP_IMAGES = {
        guild: "https://api.dicebear.com/9.x/notionists/svg?seed=Guild",
        weapon: "https://api.dicebear.com/9.x/notionists/svg?seed=Blacksmith",
        armor: "https://api.dicebear.com/9.x/notionists/svg?seed=Guard",
        item: "https://api.dicebear.com/9.x/notionists/svg?seed=Merchant",
        magic: "https://api.dicebear.com/9.x/notionists/svg?seed=Wizard"
      };

      window.LOOT_NAMES = {
        [window.Language.EN]: {
          weapons: ["Carving Knife", "Fork of Destiny", "Turkey Slayer", "Gravy Blade"],
          armors: ["Apron of Protection", "Oven Mitts", "Plated Bib", "Golden Crust Mail"],
          grimoires: ["Recipe: Roast", "Recipe: Brine", "Sauce Tactics", "Holiday Spirit"]
        },
        [window.Language.ZH]: {
          weapons: ["åˆ‡è‚‰åˆ€", "å‘½é‹ä¹‹å‰", "å± é›è€…å¤§åŠ", "è‚‰æ±é•·åŠ"],
          armors: ["é˜²è­·åœè£™", "éš”ç†±æ‰‹å¥—", "åˆé‡‘åœå…œ", "é‡‘é»ƒé…¥è„†ç”²"],
          grimoires: ["ç§˜å‚³ï¼šç‚™çƒ¤", "ç§˜å‚³ï¼šé¹½æ¼¬", "é†¬æ±æˆ°è¡“", "ç¯€æ…¶ç²¾ç¥"]
        }
      };

      window.NPC_DIALOGUES = [
          "è½èªªåŸå¤–çš„ç«é›æœƒå™´ç«ï¼Œæ˜¯çœŸçš„å—ï¼Ÿ",
          "æœ€è¿‘è”¬èœæ¼²åƒ¹äº†ï¼Œéƒ½æ˜¯é‚£äº›å·¨å‹é›å®³çš„ã€‚",
          "å¥½æƒ³åƒçœŸæ­£çš„çƒ¤é›ï¼Œè€Œä¸æ˜¯è¢«é›çƒ¤ã€‚",
          "å†’éšªè€…å…¬æœƒçš„å’–å•¡å¾ˆå¥½å–å–”ã€‚",
          "ä½ æœ‰çœ‹åˆ°ç´…é ­é«®çš„å¥³å­©è·‘éå»å—ï¼Ÿ",
          "æˆ‘çš„ç›¾ç‰Œè¢«å•„äº†ä¸€å€‹å¤§æ´...",
          "å¦‚æœä¸–ç•Œå’Œå¹³äº†ï¼Œæˆ‘æƒ³é–‹ä¸€å®¶éºµåŒ…åº—ã€‚",
          "ä¸è¦å°çœ‹æ†¤æ€’çš„å®¶ç¦½ï¼Œç‰ å€‘æœ‰åœ˜é«”æˆ°è¡“ã€‚",
          "è½èªªæ”¶é›†ç¾½æ¯›å¯ä»¥æ›åˆ°ç¥ç¥•ç¦®ç‰©ï¼Ÿ",
          "å°å¿ƒåœ°ä¸‹åŸçš„å¯¶ç®±ï¼Œæœ‰æ™‚å€™æ˜¯é™·é˜±ã€‚"
      ];

      window.NPC_NAMES = ["æ‘æ°‘A", "è€çˆºçˆº", "ç†±å¿ƒå¤§å¬¸", "é ‘çš®å°å­©", "æ—…è¡Œå•†äºº", "è­¦è¡›", "è¾²å¤«"];

      window.TILE_COLORS = {
        W: 'bg-blue-600',
        G: 'bg-green-700',
        F: 'bg-green-900',
        M: 'bg-gray-600',
        V: 'bg-red-700',
        C: 'bg-yellow-600',
        H: 'bg-emerald-700',
        K: 'bg-blue-400',
        U: 'bg-purple-600',
        _: 'bg-gray-900', 
        R: 'bg-gray-600', 
        T: 'bg-green-800', 
        N: 'bg-orange-800', 
        g: 'bg-blue-800', 
        w: 'bg-red-800', 
        a: 'bg-slate-500', 
        i: 'bg-yellow-800', 
        m: 'bg-purple-900', 
        E: 'bg-red-900', 
        f: 'bg-slate-900', 
        d: 'bg-slate-700', 
        S: 'bg-yellow-600', 
        B: 'bg-red-900', 
      };

      window.TILE_ICONS = {
        W: 'ğŸŒŠ', G: '', F: 'ğŸŒ²', M: 'â›°ï¸', V: 'ğŸŒ‹', C: 'ğŸ°', H: 'ğŸ¡', K: 'ğŸ«', U: 'ğŸ›ï¸',
        _: '', R: '', T: 'ğŸŒ³', N: 'ğŸ ', g: 'ğŸ°', w: 'âš”ï¸', a: 'ğŸ›¡ï¸', i: 'ğŸ’Š', m: 'ğŸ”®', E: 'ğŸšª', 
        f: '', d: 'ğŸ§±', S: 'ğŸªœ', B: 'â˜ ï¸',
      };

      window.ENCOUNTER_RATES = {
        G: 0.1,  
        F: 0.2,  
        M: 0.3,  
        V: 0.4,
        f: 0.35, 
      };

      window.MAP_AVONLEA = [
        ['W','W','W','W','W','W','W','W','W','W','W','W','W','W','W'],
        ['W','G','G','G','F','F','F','M','M','M','M','M','F','F','W'],
        ['W','G','C','G','F','F','G','G','M','M','M','F','V','F','W'],
        ['W','G','G','G','F','F','F','M','M','M','F','F','F','M','W'],
        ['W','G','G','G','F','F','F','M','M','M','M','F','M','M','W'],
        ['W','G','G','G','F','F','F','F','G','G','G','M','M','W','W'],
        ['W','G','G','G','G','G','G','F','G','H','G','M','W','W','W'],
        ['W','W','G','M','M','G','G','G','G','G','G','W','W','W','W'],
        ['W','W','W','W','M','G','G','G','G','W','W','W','W','W','W'],
        ['W','W','W','W','W','W','W','W','W','W','W','W','W','W','W'],
      ];

      window.MAP_CAVENDISH = [
          ['W','W','W','W','W','W','W','W','W','W','W','W','W','W','W'],
          ['W','G','G','G','G','G','G','G','F','F','M','M','M','M','W'],
          ['W','G','C','G','G','G','G','G','F','F','M','M','V','M','W'],
          ['W','G','G','G','F','F','F','M','M','M','F','F','F','F','W'],
          ['W','G','G','F','F','F','F','G','G','G','G','G','G','G','W'],
          ['W','G','G','G','F','F','F','F','G','G','G','G','G','W','W'],
          ['W','G','G','G','G','G','G','F','G','K','G','M','W','W','W'],
          ['W','W','G','M','M','G','G','G','G','G','G','W','W','W','W'],
          ['W','W','W','W','M','G','G','G','G','W','W','W','W','W','W'],
          ['W','W','W','W','W','W','W','W','W','W','W','W','W','W','W'],
      ];

      window.MAP_CHARLOTTETOWN = [
        ['W','W','W','W','W','W','W','W','W','W','W','W','W','W','W'],
        ['W','G','G','G','G','G','G','G','M','M','M','M','M','M','W'],
        ['W','G','C','G','G','G','G','G','M','M','M','M','V','M','W'],
        ['W','G','G','G','F','F','F','M','M','M','G','G','G','G','W'],
        ['W','G','G','F','F','F','F','G','G','G','G','G','G','G','W'],
        ['W','G','G','G','F','F','F','F','G','G','G','G','G','W','W'],
        ['W','G','G','G','G','G','G','F','G','U','G','M','W','W','W'],
        ['W','W','G','M','M','G','G','G','G','G','G','W','W','W','W'],
        ['W','W','W','W','M','G','G','G','G','W','W','W','W','W','W'],
        ['W','W','W','W','W','W','W','W','W','W','W','W','W','W','W'],
      ];

      window.TOWN_MAP = [
          ['T','T','T','T','T','T','T','T','T','T','T','T','T','T','T'],
          ['T','N','N','T','g','T','m','T','N','N','T','N','N','T','T'], 
          ['T','R','R','R','R','R','R','R','R','R','R','R','R','R','T'], 
          ['T','R','T','T','T','R','T','R','T','T','T','R','T','R','T'],
          ['T','R','w','T','a','R','i','R','N','T','N','R','N','R','T'], 
          ['T','R','R','R','R','R','R','R','R','R','R','R','R','R','T'], 
          ['T','R','R','R','R','R','R','R','R','R','R','R','R','R','T'],
          ['T','T','T','T','T','T','R','T','T','T','T','T','T','T','T'],
          ['T','T','T','T','T','T','E','T','T','T','T','T','T','T','T'],
      ];

      window.DUNGEON_B1_MAP = [
          ['d','d','d','d','d','d','d','d','d','d','d','d','d','d','d'],
          ['d','d','d','d','d','f','f','f','f','f','f','d','B','d','d'],
          ['d','f','f','f','d','f','d','d','d','d','f','d','f','d','d'],
          ['d','f','d','f','d','f','d','d','f','f','f','f','f','f','d'],
          ['d','f','d','f','d','f','f','f','f','d','d','d','d','f','d'],
          ['d','f','d','f','d','d','d','d','d','d','f','f','f','f','d'],
          ['d','f','f','f','f','f','f','f','f','f','f','d','d','d','d'],
          ['d','E','d','d','d','d','d','d','d','d','d','d','d','d','d'],
          ['d','d','d','d','d','d','d','d','d','d','d','d','d','d','d']
      ];

      window.DUNGEON_B2_MAP = [
          ['d','d','d','d','d','d','d','d','d','d','d','d','d','d','d'],
          ['d','B','f','f','f','f','d','d','d','d','d','d','S','d','d'],
          ['d','d','d','d','d','f','d','f','f','f','f','d','f','d','d'],
          ['d','f','f','f','f','f','d','f','d','d','f','d','f','d','d'],
          ['d','f','d','d','d','d','d','f','d','d','f','d','f','d','d'],
          ['d','f','d','f','f','f','f','f','f','f','f','f','f','d','d'],
          ['d','f','d','f','f','f','f','f','f','f','f','f','f','d','d'],
          ['d','f','f','f','d','d','d','d','d','d','d','d','d','d','d'],
          ['d','d','d','d','d','d','d','d','d','d','d','d','d','d','d']
      ];

      window.MAP_START_POS = { x: 2, y: 2 };
      window.TOWN_START_POS = { x: 6, y: 7 }; 
      window.DUNGEON_START_POS = { x: 1, y: 7 };
    </script>

    <!-- ========================================== -->
    <!-- 2. Services (Audio & AI) (Standard JS)     -->
    <!-- ========================================== -->
    <script>
      // AudioService
      class AudioService {
        constructor() {
          this.ctx = null;
          this.isMuted = false;
          this.currentBgm = null;
          this.intervalId = null;
        }

        async init() {
          if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          }
          if (this.ctx.state === 'suspended') {
            await this.ctx.resume();
          }
        }

        playSfx(type) {
          if (!this.ctx || this.isMuted) return;
          if (this.ctx.state === 'suspended') this.ctx.resume().catch(() => {});

          const now = this.ctx.currentTime;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.connect(gain);
          gain.connect(this.ctx.destination);

          switch (type) {
            case 'SELECT':
              osc.type = 'square';
              osc.frequency.setValueAtTime(440, now);
              osc.frequency.exponentialRampToValueAtTime(880, now + 0.05);
              gain.gain.setValueAtTime(0.05, now);
              gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
              osc.start(now);
              osc.stop(now + 0.05);
              break;
            case 'CONFIRM':
              osc.type = 'square';
              osc.frequency.setValueAtTime(880, now);
              osc.frequency.setValueAtTime(1760, now + 0.1);
              gain.gain.setValueAtTime(0.05, now);
              gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
              osc.start(now);
              osc.stop(now + 0.3);
              break;
            case 'CANCEL':
              osc.type = 'sawtooth';
              osc.frequency.setValueAtTime(150, now);
              osc.frequency.linearRampToValueAtTime(100, now + 0.15);
              gain.gain.setValueAtTime(0.05, now);
              gain.gain.linearRampToValueAtTime(0.001, now + 0.15);
              osc.start(now);
              osc.stop(now + 0.15);
              break;
            case 'ATTACK':
              osc.type = 'sawtooth';
              osc.frequency.setValueAtTime(100, now);
              osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
              gain.gain.setValueAtTime(0.05, now);
              gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
              osc.start(now);
              osc.stop(now + 0.1);
              break;
            case 'HIT':
              osc.type = 'square';
              osc.frequency.setValueAtTime(100, now);
              osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
              gain.gain.setValueAtTime(0.1, now);
              gain.gain.linearRampToValueAtTime(0.001, now + 0.15);
              osc.start(now);
              osc.stop(now + 0.15);
              break;
            case 'HEAL':
              osc.type = 'sine';
              osc.frequency.setValueAtTime(440, now);
              osc.frequency.linearRampToValueAtTime(880, now + 0.2);
              osc.frequency.linearRampToValueAtTime(1760, now + 0.4);
              gain.gain.setValueAtTime(0.05, now);
              gain.gain.linearRampToValueAtTime(0.001, now + 0.6);
              osc.start(now);
              osc.stop(now + 0.6);
              break;
            case 'WIN':
              this.playMelody([523.25, 523.25, 523.25, 659.25, 783.99, 1046.50], 0.12, 'square');
              break;
            case 'LOSE':
              osc.type = 'triangle';
              osc.frequency.setValueAtTime(440, now);
              osc.frequency.linearRampToValueAtTime(220, now + 0.6);
              osc.frequency.linearRampToValueAtTime(110, now + 1.2);
              gain.gain.setValueAtTime(0.1, now);
              gain.gain.linearRampToValueAtTime(0.001, now + 1.2);
              osc.start(now);
              osc.stop(now + 1.2);
              break;
          }
        }

        playMelody(freqs, duration, type) {
          if (!this.ctx) return;
          const now = this.ctx.currentTime;
          freqs.forEach((f, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.value = f;
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            
            const startTime = now + i * duration;
            gain.gain.setValueAtTime(0.05, startTime);
            gain.gain.setValueAtTime(0, startTime + duration - 0.02);
            
            osc.start(startTime);
            osc.stop(startTime + duration);
          });
        }

        stopBgm() {
          if (this.intervalId) {
            window.clearInterval(this.intervalId);
            this.intervalId = null;
          }
          this.currentBgm = null;
        }

        playBgm(type) {
          if (this.currentBgm === type) return;
          this.stopBgm();
          this.currentBgm = type;
          
          if (this.isMuted) return;

          this.init().catch(() => {});

          let noteIndex = 0;
          let sequence = [];
          let speed = 200;
          let waveform = 'triangle';

          if (type === 'TITLE') {
            sequence = [392, 0, 392, 0, 392, 440, 493, 392, 523, 0, 0, 0]; 
            speed = 250;
            waveform = 'square';
          } else if (type === 'MAP') {
            sequence = [261, 329, 392, 329, 440, 392, 349, 329]; 
            speed = 400;
            waveform = 'triangle';
          } else if (type === 'BATTLE') {
            sequence = [110, 110, 116, 110, 123, 110, 130, 110]; 
            speed = 120;
            waveform = 'sawtooth';
          }

          this.intervalId = window.setInterval(() => {
              if (!this.ctx || this.isMuted || this.ctx.state === 'suspended') return;
              
              const freq = sequence[noteIndex];
              
              if (freq > 0) {
                  const osc = this.ctx.createOscillator();
                  const gain = this.ctx.createGain();
                  
                  osc.type = waveform;
                  osc.frequency.value = freq;
                  
                  osc.connect(gain);
                  gain.connect(this.ctx.destination);
                  
                  const now = this.ctx.currentTime;
                  gain.gain.setValueAtTime(0.03, now);
                  gain.gain.exponentialRampToValueAtTime(0.001, now + (speed/1000));
                  
                  osc.start(now);
                  osc.stop(now + (speed/1000));
              }

              noteIndex = (noteIndex + 1) % sequence.length;
          }, speed);
        }

        toggleMute() {
          this.isMuted = !this.isMuted;
          if (this.isMuted) {
              this.stopBgm();
          } else {
              const resumeType = this.currentBgm;
              this.currentBgm = null; 
              if (resumeType) this.playBgm(resumeType);
          }
          return this.isMuted;
        }
      }

      // Expose AudioService instance globally
      window.audioService = new AudioService();

      // Gemini Service Helpers
      const getClient = () => {
        const localKey = localStorage.getItem('gemini_api_key');
        if (localKey) {
            return new window.GoogleGenAI({ apiKey: localKey });
        }
        if (!window.process.env.API_KEY) {
          console.warn("API_KEY is missing. Using fallback mock data.");
          return null;
        }
        return new window.GoogleGenAI({ apiKey: window.process.env.API_KEY });
      };

      window.generateDinosaur = async (targetLevel, lang) => {
        const ai = getClient();
        const isZh = lang === window.Language.ZH;

        if (!ai) {
           const bonus = Math.max(0, targetLevel - 1) * 2;
           return {
            name: isZh ? "æ†¤æ€’ç«é›" : "Angry Turkey",
            level: targetLevel,
            hp: 20 + targetLevel * 10 + bonus * 5,
            maxHp: 20 + targetLevel * 10 + bonus * 5,
            mp: 10 + targetLevel * 5,
            maxMp: 10 + targetLevel * 5,
            attack: 5 + targetLevel * 2 + bonus,
            defense: 2 + targetLevel + bonus,
            description: isZh 
              ? "ä¸€éš»è¢«æ¿€æ€’çš„å·¨å‹ç«é›ï¼Œçœ¼ç¥ä¸­ç‡ƒç‡’è‘—å°æ„Ÿæ©ç¯€çš„å¾©ä»‡ä¹‹ç«ã€‚" 
              : "A giant turkey fueled by rage and vengeance against Thanksgiving.",
            imageUrl: window.MONSTER_FALLBACK_URL 
          };
        }

        const langPrompt = isZh ? "Traditional Chinese (Taiwan)" : "English";
        const prompt = `Generate a 'Mutant Turkey Monster' or 'Poultry Beast' enemy for a satirical retro RPG game. 
        Theme: Turkeys taking over the world, mecha-turkeys, ancient god turkeys, magical chickens.
        Level: ${targetLevel}.
        Language: ${langPrompt}.
        Return JSON with:
        - name (Creative name like 'Mecha-Gobbler', 'Count Turkula'. Do NOT include 'Lv.' in the name string)
        - hp (integer, balanced for Level ${targetLevel})
        - mp (integer, balanced for Level ${targetLevel})
        - attack (integer, balanced for Level ${targetLevel})
        - defense (integer, balanced for Level ${targetLevel})
        - description (Funny but epic RPG flavor text, max 2 sentences)
        - visualPrompt (A short English description strictly for generating a pixel art image of this monster. MUST include the word 'Turkey' or 'Chicken' monster. Example: 'A cyborg turkey with laser eyes', 'A giant turkey wearing knight armor'. Describe color, features, and pose.)`;

        try {
          const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
            config: {
              responseMimeType: 'application/json',
              responseSchema: {
                type: window.GenAIType.OBJECT,
                properties: {
                  name: { type: window.GenAIType.STRING },
                  hp: { type: window.GenAIType.INTEGER },
                  mp: { type: window.GenAIType.INTEGER },
                  attack: { type: window.GenAIType.INTEGER },
                  defense: { type: window.GenAIType.INTEGER },
                  description: { type: window.GenAIType.STRING },
                  visualPrompt: { type: window.GenAIType.STRING }
                },
                required: ['name', 'hp', 'mp', 'attack', 'defense', 'description', 'visualPrompt']
              }
            }
          });

          const data = JSON.parse(response.text || '{}');
          let imageUrl = window.MONSTER_FALLBACK_URL;

          try {
            const imagePrompt = `Pixel art sprite of a ${data.visualPrompt}. Retro 16-bit RPG style monster, isolated on white background, full body visible. High quality, crisp lines, fantasy style.`;
            
            const imageGenPromise = ai.models.generateContent({
              model: 'gemini-2.5-flash-image', // Fixed: Use correct model for image generation
              contents: {
                parts: [{ text: imagePrompt }]
              },
              config: {
                  imageConfig: {
                      aspectRatio: "1:1",
                  }
              }
            });

            const timeoutPromise = new Promise((_, reject) => 
              setTimeout(() => reject(new Error("Image generation timed out")), 15000)
            );

            const imageResponse = await Promise.race([imageGenPromise, timeoutPromise]);

            for (const part of imageResponse.candidates[0].content.parts) {
              if (part.inlineData) {
                imageUrl = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
                break;
              }
            }
          } catch (imgError) {
            console.warn("Image generation skipped or failed:", imgError);
          }

          return {
            name: data.name,
            level: targetLevel,
            hp: data.hp,
            maxHp: data.hp,
            mp: data.mp,
            maxMp: data.mp,
            attack: data.attack,
            defense: data.defense,
            description: data.description,
            imageUrl: imageUrl
          };

        } catch (error) {
          console.error("Gemini API Error:", error);
          const bonus = Math.max(0, targetLevel - 1) * 2;
          return {
            name: isZh ? "AIé¡åº¦éŒ¯èª¤ç«é›" : "Glitch-Gobbler out of AI point",
            level: targetLevel,
            hp: 20 + targetLevel * 10 + bonus * 5,
            maxHp: 20 + targetLevel * 10 + bonus * 5,
            mp: 10 + targetLevel * 5,
            maxMp: 10 + targetLevel * 5,
            attack: 5 + targetLevel * 2 + bonus,
            defense: 2 + targetLevel + bonus,
            description: isZh ? "å› AIé¡åº¦ç”¨å®ŒéŒ¯èª¤è€Œèª•ç”Ÿçš„æ€ªç‰©ã€‚" : "A digital poultry born from out of AI point.",
            imageUrl: window.MONSTER_FALLBACK_URL
          };
        }
      };
    </script>

    <!-- ========================================== -->
    <!-- 3. Logic & Views (JSX)                     -->
    <!-- ========================================== -->
    <script type="text/babel">
      // Explicitly capture React and ReactDOM from window to avoid undefined errors
      const React = window.React;
      const ReactDOM = window.ReactDOM;
      const { useState, useEffect, useRef, useCallback } = React;

      const RetroWindow = ({ children, className = '', title }) => {
        return (
          <div className={`relative bg-blue-900 border-4 double border-white rounded-sm p-4 text-white shadow-lg ${className}`}>
            {title && (
              <div className="absolute -top-3 left-4 bg-blue-900 px-2 text-xl font-bold tracking-wider text-yellow-300 border border-white z-10 text-shadow-retro">
                {title}
              </div>
            )}
            {children}
          </div>
        );
      };

      const RetroButton = ({ children, active, className = '', ...props }) => {
        return (
          <button
            className={`
              w-full text-left px-4 py-2 uppercase font-bold text-lg tracking-wider outline-none
              transition-colors duration-100 flex items-center
              ${active ? 'bg-orange-500 text-white animate-pulse' : 'hover:bg-blue-800 text-gray-200'}
              ${className}
            `}
            {...props}
          >
            <span className={`mr-2 ${active ? 'opacity-100' : 'opacity-0'}`}>â–¶</span>
            {children}
          </button>
        );
      };

      const TitleBadge = ({ className }) => {
        return (
          <svg viewBox="0 0 240 240" className={className} xmlns="http://www.w3.org/2000/svg">
            <defs>
              <linearGradient id="shieldGold" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stopColor="#FCD34D" />
                <stop offset="40%" stopColor="#D97706" />
                <stop offset="100%" stopColor="#78350F" />
              </linearGradient>
              <linearGradient id="shieldRed" x1="50%" y1="0%" x2="50%" y2="100%">
                <stop offset="0%" stopColor="#991B1B" />
                <stop offset="100%" stopColor="#450A0A" />
              </linearGradient>
              <linearGradient id="bladeSteel" x1="0%" y1="50%" x2="100%" y2="50%">
                <stop offset="0%" stopColor="#E5E7EB" />
                <stop offset="50%" stopColor="#FFFFFF" />
                <stop offset="52%" stopColor="#9CA3AF" />
                <stop offset="100%" stopColor="#374151" />
              </linearGradient>
              <radialGradient id="magicOrb" cx="30%" cy="30%" r="70%">
                <stop offset="0%" stopColor="#FBCFE8" />
                <stop offset="20%" stopColor="#C084FC" />
                <stop offset="100%" stopColor="#581C87" />
              </radialGradient>
              <filter id="dropShadow" x="-20%" y="-20%" width="140%" height="140%">
                <feGaussianBlur in="SourceAlpha" stdDeviation="3" />
                <feOffset dx="2" dy="4" result="offsetblur" />
                <feComponentTransfer>
                  <feFuncA type="linear" slope="0.5" />
                </feComponentTransfer>
                <feMerge>
                  <feMergeNode />
                  <feMergeNode in="SourceGraphic" />
                </feMerge>
              </filter>
            </defs>
            <g filter="url(#dropShadow)">
              <path d="M120 20 C 200 20, 200 60, 200 90 C 200 160, 120 220, 120 220 C 120 220, 40 160, 40 90 C 40 60, 40 20, 120 20 Z" fill="url(#shieldGold)" stroke="#451a03" strokeWidth="3" />
              <path d="M120 35 C 180 35, 180 65, 180 90 C 180 145, 120 195, 120 195 C 120 195, 60 145, 60 90 C 60 65, 60 35, 120 35 Z" fill="url(#shieldRed)" stroke="#B45309" strokeWidth="2" />
              <path d="M120 60 Q 140 60, 150 80 Q 160 100, 120 140 Q 80 100, 90 80 Q 100 60, 120 60 Z" fill="#D97706" opacity="0.3" />
              <path d="M120 65 Q 135 65, 140 80 Q 145 95, 120 120 Q 95 95, 100 80 Q 105 65, 120 65 Z" fill="#FCD34D" opacity="0.5" />
            </g>
            <g transform="rotate(45, 120, 120)" filter="url(#dropShadow)">
              <rect x="116" y="20" width="8" height="200" rx="4" fill="#3E2723" stroke="#2a1810" strokeWidth="1" />
              <circle cx="120" cy="20" r="14" fill="url(#magicOrb)" />
              <circle cx="120" cy="20" r="14" fill="none" stroke="#E9D5FF" strokeWidth="2" opacity="0.8" />
            </g>
            <g transform="rotate(-45, 120, 120)" filter="url(#dropShadow)">
               <path d="M115 30 L120 10 L125 30 L125 180 L115 180 Z" fill="url(#bladeSteel)" stroke="#374151" strokeWidth="1" />
               <line x1="120" y1="30" x2="120" y2="180" stroke="#9CA3AF" strokeWidth="1" />
               <rect x="100" y="180" width="40" height="8" rx="2" fill="#D97706" stroke="#78350F" strokeWidth="1" />
               <rect x="105" y="178" width="30" height="12" rx="1" fill="url(#shieldGold)" opacity="0.5" />
               <rect x="117" y="188" width="6" height="30" fill="#451a03" />
               <circle cx="120" cy="222" r="7" fill="#D97706" stroke="#78350F" strokeWidth="2" />
            </g>
            <path d="M120 30 C 130 30, 135 40, 135 60 C 135 60, 120 40, 120 30 Z" fill="white" opacity="0.4" />
          </svg>
        );
      };

      const VirtualPad = ({ onUp, onDown, onSelect }) => {
        return (
          <div className="fixed bottom-4 right-4 flex flex-col items-center gap-2 z-50 md:hidden opacity-80">
            <div className="flex gap-2">
              <button onClick={onUp} className="w-14 h-14 bg-gray-700 rounded-full border-2 border-white text-2xl active:bg-gray-500 flex items-center justify-center shadow-lg">â–²</button>
            </div>
            <div className="flex gap-14"></div>
            <div className="flex gap-2">
              <button onClick={onDown} className="w-14 h-14 bg-gray-700 rounded-full border-2 border-white text-2xl active:bg-gray-500 flex items-center justify-center shadow-lg">â–¼</button>
            </div>
            <button onClick={onSelect} className="fixed bottom-12 right-6 w-20 h-20 bg-red-700 rounded-full border-4 border-white text-xl font-bold active:bg-red-500 shadow-xl">A</button>
          </div>
        );
      };

      const StatusPanel = ({ player, t, canHeal, onHeal }) => {
          const nextLevelExp = player.level * 50; 
          const displayTitle = `${player.name} â˜…${player.reincarnationCount}`;
          const totalAtk = 13 + Math.floor(player.level * 2) + player.equipmentAtk;
          const totalDef = 5 + Math.floor(player.level / 2) + player.equipmentDef;

          return (
          <RetroWindow title={displayTitle} className="h-full bg-blue-900/80 flex flex-col p-2 md:p-4">
              <div className="space-y-1 md:space-y-3 text-sm md:text-2xl font-bold tracking-wide flex-1 text-shadow-retro">
                  <div className="flex items-center gap-2 border-b border-blue-700 pb-1 text-base md:text-lg">
                      <span className="text-yellow-400 whitespace-nowrap">{t.lvl} {player.level}</span>
                      <div className="flex-1 flex items-center gap-2">
                          <div className="flex-1 bg-gray-800 h-2 rounded-full overflow-hidden border border-gray-500 relative">
                              <div className="bg-purple-500 h-full" style={{ width: `${Math.min(100, (player.exp / nextLevelExp) * 100)}%` }}></div>
                          </div>
                          <span className="text-[10px] md:text-xs text-gray-400">{player.exp}/{nextLevelExp}</span>
                      </div>
                  </div>
                  
                  <div className="space-y-1">
                      <div className="flex justify-between text-xs md:text-base text-gray-300">
                          <span>{t.hp}</span>
                          <span>{player.hp.toLocaleString()}/{player.maxHp.toLocaleString()}</span>
                      </div>
                      <div className="w-full bg-gray-800 h-2 md:h-3 rounded-full overflow-hidden border border-gray-500">
                          <div className="bg-gradient-to-r from-green-600 to-green-400 h-full" style={{ width: `${(player.hp / player.maxHp) * 100}%` }}></div>
                      </div>
                  </div>

                  <div className="space-y-1">
                      <div className="flex justify-between text-xs md:text-base text-gray-300">
                          <span>{t.mp}</span>
                          <span>{player.mp.toLocaleString()}/{player.maxMp.toLocaleString()}</span>
                      </div>
                      <div className="w-full bg-gray-800 h-2 md:h-3 rounded-full overflow-hidden border border-gray-500">
                          <div className="bg-gradient-to-r from-blue-600 to-blue-400 h-full" style={{ width: `${(player.mp / player.maxMp) * 100}%` }}></div>
                      </div>
                  </div>

                  <div className="grid grid-cols-2 gap-2 mt-1 md:mt-2 pt-1 md:pt-2 border-t border-blue-700 text-sm md:text-lg">
                      <div className="text-red-300">{t.atk}: {totalAtk.toLocaleString()}</div>
                      <div className="text-blue-300">{t.def}: {totalDef.toLocaleString()}</div>
                  </div>

                   <div className="mt-1 md:mt-2 pt-1 md:pt-2 border-t border-blue-700 space-y-1 text-xs md:text-base hidden md:block">
                      <div className="grid grid-cols-[24px_1fr] gap-2 text-orange-300 items-center">
                           <span className="flex justify-center">âš”ï¸</span>
                           <span>{t.atk} +{player.equipmentAtk.toLocaleString()}</span>
                      </div>
                      <div className="grid grid-cols-[24px_1fr] gap-2 text-gray-300 items-center">
                           <span className="flex justify-center">ğŸ›¡ï¸</span>
                           <span>{t.def} +{player.equipmentDef.toLocaleString()}</span>
                      </div>
                      <div className="grid grid-cols-[24px_1fr] gap-2 text-purple-300 items-center">
                           <span className="flex justify-center"><img src={window.POTION_ICON_URL} alt="Potion" className="w-4 h-4 object-contain" /></span>
                           <span>{t.potions} {player.potions.toLocaleString()}</span>
                      </div>
                  </div>

                  <div className="mt-1 md:mt-4 pt-1 md:pt-2 border-t border-blue-700 text-sm md:text-lg text-yellow-200">
                      ğŸ’° {player.gold.toLocaleString()} Gold
                  </div>

                  {canHeal && (
                    <div className="mt-2 pt-2 border-t border-blue-700 space-y-2">
                        <div className="text-sm md:text-base font-bold text-yellow-300 text-center">{t.quickHeal}</div>
                        <div className="flex gap-2">
                            <button 
                                onClick={(e) => { e.stopPropagation(); onHeal('MAGIC'); }}
                                className="flex-1 bg-blue-800 hover:bg-blue-600 border border-blue-400 text-sm md:text-base py-2 rounded text-white disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled={player.mp < 3 || player.hp >= player.maxHp}
                            >
                                {t.quickHealMagic}
                            </button>
                            <button 
                                onClick={(e) => { e.stopPropagation(); onHeal('POTION'); }}
                                className="flex-1 bg-red-800 hover:bg-red-600 border border-red-400 text-sm md:text-base py-2 rounded text-white disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled={player.potions <= 0 || player.hp >= player.maxHp}
                            >
                                {t.quickHealPotion}
                            </button>
                        </div>
                    </div>
                  )}
              </div>
          </RetroWindow>
          );
      };

      // Name Input Modal
      const NameInputModal = ({ playerNameInput, handleNameChange, submitName, t }) => {
          return (
              <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/90 animate-fade-in">
                  <RetroWindow className="w-full max-w-md border-white bg-blue-900 shadow-2xl p-8 flex flex-col items-center gap-6">
                      <h2 className="text-2xl text-yellow-400 font-bold">{t.naming.title}</h2>
                      <div className="w-full">
                          <input 
                              type="text" 
                              value={playerNameInput}
                              onChange={handleNameChange}
                              placeholder={t.naming.placeholder}
                              className="w-full bg-black border-2 border-gray-500 text-white text-3xl text-center p-4 outline-none focus:border-yellow-400 font-['VT323']"
                              autoFocus
                          />
                          <div className="text-sm text-gray-400 text-center mt-2">{t.naming.hint}</div>
                      </div>
                      <RetroButton onClick={submitName} className="bg-red-900 border-red-500 w-2/3 justify-center">
                          {t.naming.confirm}
                      </RetroButton>
                  </RetroWindow>
              </div>
          );
      };

      // About Modal
      const AboutModal = ({ showAboutModal, setShowAboutModal, t }) => {
          if (!showAboutModal) return null;

          return (
              <div className="absolute inset-0 z-[200] flex items-center justify-center bg-black/95 animate-fade-in p-4" onClick={(e) => e.stopPropagation()}>
                   <RetroWindow className="w-full max-w-lg border-yellow-500 bg-blue-900/90 shadow-[0_0_50px_rgba(59,130,246,0.5)] p-6 md:p-8 flex flex-col items-center gap-6">
                      <h2 className="text-2xl md:text-3xl text-yellow-400 font-bold border-b-2 border-yellow-600 pb-2 mb-2 font-['DotGothic16'] tracking-widest text-center">
                          {t.about.title}
                      </h2>
                      
                      <div className="text-white text-base md:text-lg text-left leading-relaxed font-serif space-y-4 w-full text-shadow-retro">
                          <p>{t.about.plot}</p>
                          <p className="text-gray-300">{t.about.gameplay}</p>
                          <div className="border-t border-gray-600 pt-4 mt-4 text-center">
                              <div className="text-yellow-200 font-bold">{t.about.author}</div>
                              <div className="text-blue-300">{t.about.email}</div>
                          </div>
                      </div>

                      <RetroButton 
                          onClick={() => setShowAboutModal(false)}
                          className="bg-red-900 border-red-500 text-white mt-4 w-auto min-w-[120px] py-1 justify-center text-sm"
                      >
                          {t.about.close}
                      </RetroButton>
                   </RetroWindow>
              </div>
          );
      };

      // API Key Config Modal
      const ApiKeyModal = ({ showApiKeyModal, setShowApiKeyModal, t, hasApiKey, setHasApiKey, setNotification, audioService }) => {
          if (!showApiKeyModal) return null;
          const [userApiKeyInput, setUserApiKeyInput] = useState("");

          const handleSaveApiKey = () => {
              if (!userApiKeyInput.trim()) return;
              localStorage.setItem('gemini_api_key', userApiKeyInput.trim());
              setHasApiKey(true);
              setNotification(t.apiKeyModal.savedMsg);
              setTimeout(() => { setNotification(""); setShowApiKeyModal(false); }, 1500);
              audioService.playSfx('CONFIRM');
          };

          const handleClearApiKey = () => {
              localStorage.removeItem('gemini_api_key');
              setUserApiKeyInput("");
              setHasApiKey(false);
              setNotification(t.apiKeyModal.clearedMsg);
              setTimeout(() => setNotification(""), 1500);
              audioService.playSfx('CANCEL');
          };

          return (
              <div className="absolute inset-0 z-[200] flex items-center justify-center bg-black/95 animate-fade-in p-4" onClick={(e) => e.stopPropagation()}>
                   <RetroWindow className="w-full max-w-lg border-blue-500 bg-gray-900 shadow-[0_0_50px_rgba(59,130,246,0.5)] p-6 md:p-8 flex flex-col items-center gap-6">
                      <h2 className="text-2xl md:text-3xl text-blue-400 font-bold border-b-2 border-blue-700 pb-2 mb-2 font-['DotGothic16'] tracking-widest text-center w-full">
                          {t.apiKeyModal.title}
                      </h2>
                      
                      <p className="text-sm text-yellow-100 text-center mb-2 px-2 leading-relaxed">
                          {t.apiKeyModal.explanation}
                      </p>

                      <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" className="text-blue-400 text-sm underline hover:text-blue-300 mb-4 block text-center font-bold">
                          {t.apiKeyModal.getApiKeyLink} ğŸ”—
                      </a>

                      <div className="w-full space-y-4">
                          <input 
                              type="password" 
                              value={userApiKeyInput}
                              onChange={(e) => setUserApiKeyInput(e.target.value)}
                              placeholder={t.apiKeyModal.placeholder}
                              className="w-full bg-black border border-gray-600 text-white p-3 rounded focus:border-blue-400 outline-none font-mono text-sm"
                          />
                          <p className="text-xs text-gray-400 text-center">{t.apiKeyModal.hint}</p>
                      </div>

                      <div className="flex gap-4 w-full mt-2">
                          <RetroButton 
                              onClick={handleSaveApiKey}
                              className="bg-green-900 border-green-600 text-white flex-1 justify-center text-sm md:text-base"
                          >
                              {t.apiKeyModal.save}
                          </RetroButton>
                          <RetroButton 
                              onClick={handleClearApiKey}
                              className="bg-red-900 border-red-600 text-white flex-1 justify-center text-sm md:text-base"
                          >
                              {t.apiKeyModal.clear}
                          </RetroButton>
                      </div>

                      <RetroButton 
                          onClick={() => setShowApiKeyModal(false)}
                          className="bg-gray-800 border-gray-600 text-white w-full justify-center text-sm mt-2"
                      >
                          {t.apiKeyModal.close}
                      </RetroButton>
                   </RetroWindow>
              </div>
          );
      };

      // Reincarnation Modal
      const ReincarnationModal = ({ showReincarnationModal, pendingReincarnationPlayer, confirmReincarnation, t }) => {
          if (!showReincarnationModal || !pendingReincarnationPlayer) return null;

          return (
              <div className="absolute inset-0 z-[200] flex items-center justify-center bg-black/95 animate-fade-in p-4">
                   <RetroWindow className="w-full max-w-lg border-yellow-500 bg-purple-900/90 shadow-[0_0_50px_rgba(168,85,247,0.5)] p-6 md:p-8 flex flex-col items-center gap-6">
                      <h2 className="text-3xl md:text-4xl text-yellow-400 font-bold border-b-2 border-yellow-600 pb-2 mb-2 font-['DotGothic16'] tracking-widest text-center">
                          {t.reincarnationModal.title}
                      </h2>
                      
                      <div className="text-white text-base md:text-xl text-center leading-relaxed whitespace-pre-wrap font-serif text-shadow-retro">
                          {t.reincarnationModal.message(pendingReincarnationPlayer.reincarnationCount)}
                      </div>

                      <div className="bg-black/50 p-4 rounded border border-purple-400 w-full text-center">
                          <div className="text-green-400 font-bold text-xl md:text-2xl mb-2 animate-pulse text-shadow-retro">
                              {t.reincarnationModal.bonus}
                          </div>
                      </div>

                      <RetroButton 
                          onClick={confirmReincarnation}
                          className="bg-yellow-700 border-yellow-400 text-white text-xl py-4 hover:bg-yellow-600 animate-pulse mt-4"
                      >
                          {t.reincarnationModal.confirm}
                      </RetroButton>
                   </RetroWindow>
              </div>
          );
      };

      // Save/Load Menu
      const SaveLoadMenu = ({ showSaveMenu, setShowSaveMenu, setShowLoadMenu, saveMessage, t, saveGame, loadGame }) => {
          const isSave = showSaveMenu;
          const title = isSave ? t.saveLoad.saveTitle : t.saveLoad.loadTitle;

          const getSaveSlots = () => {
              const slots = [];
              for(let i=1; i<=5; i++) {
                  const data = localStorage.getItem(`turkey_quest_save_${i}`);
                  slots.push(data ? JSON.parse(data) : null);
              }
              return slots;
          };
          
          const slots = getSaveSlots();

          return (
              <div className="absolute inset-0 z-50 bg-black/80 flex items-center justify-center p-4">
                  <RetroWindow className="w-full max-w-2xl border-yellow-500 bg-blue-900 shadow-2xl">
                      <h2 className="text-2xl text-yellow-400 font-bold border-b border-yellow-600 pb-2 mb-4">{title}</h2>
                      
                      {saveMessage && (
                          <div className="bg-green-800 text-white p-2 mb-4 text-center rounded animate-bounce">
                              {saveMessage}
                          </div>
                      )}

                      <div className="grid gap-2 max-h-[60vh] overflow-y-auto pr-2">
                          {slots.map((slot, index) => (
                              <div key={index} className="flex gap-2">
                                  <RetroButton 
                                      onClick={() => isSave ? saveGame(index) : (slot ? loadGame(index) : null)}
                                      className={`flex-1 border-2 text-sm md:text-base py-3 ${slot ? 'bg-blue-900/50 border-blue-400' : 'bg-gray-800 border-gray-600 text-gray-500'}`}
                                  >
                                      {slot ? (
                                        <div className="grid grid-cols-[1fr_auto] w-full items-center">
                                            <div className="flex flex-col items-start">
                                                <div className="text-yellow-300 font-bold text-lg">LV.{slot.player.level} {slot.player.name}</div>
                                                <div className="text-gray-200 text-sm">{index + 1}. {slot.locationLabel}</div>
                                            </div>
                                            <div className="text-xs text-gray-400">{new Date(slot.timestamp).toLocaleString()}</div>
                                        </div>
                                      ) : (
                                        <div className="w-full text-left">{index + 1}. {t.saveLoad.emptySlot}</div>
                                      )}
                                  </RetroButton>
                              </div>
                          ))}
                      </div>

                      <div className="mt-6 flex justify-end">
                          <RetroButton 
                              onClick={() => { setShowSaveMenu(false); setShowLoadMenu(false); }}
                              className="bg-red-900 border-red-500 w-auto px-8"
                          >
                              {t.saveLoad.backBtn}
                          </RetroButton>
                      </div>
                  </RetroWindow>
              </div>
          );
      };

      const TitleScreen = ({ 
          t, lang, setLang, titleSelection, setTitleSelection, handleInput, 
          setShowLoadMenu, setShowApiKeyModal, setShowAboutModal, 
          hasSaves, hasApiKey, audioService, setGameState, setPlayer, setMapMessage 
      }) => {
          
          const handleGodMode = (e) => {
              e.stopPropagation();
              // Just trigger audio context
              audioService.init().catch(console.error);
              audioService.playSfx('WIN'); 
              setPlayer({...window.GOD_MODE_PLAYER});
              setGameState(window.GameState.MAP);
              setMapMessage(t.dungeon.title);
          };

          return (
          <div className="relative w-full h-full flex flex-col items-center justify-center text-center animate-fade-in p-4">
             <div 
               className="absolute top-4 right-4 text-gray-400 font-mono text-lg md:text-2xl z-50 opacity-80 font-bold cursor-pointer hover:text-yellow-400 transition-colors underline decoration-dotted decoration-gray-600 hover:decoration-yellow-400"
               onClick={(e) => { e.stopPropagation(); setShowAboutModal(true); }}
               title={t.about.title}
             >
                {window.GAME_VERSION}
             </div>
             
             <div 
                className="absolute inset-0 z-0 opacity-60" 
                style={{ 
                    backgroundImage: 'url(https://images.unsplash.com/photo-1533154683836-84ea7a0bc310?q=80&w=2000&auto=format&fit=crop)',
                    backgroundSize: 'cover',
                    backgroundPosition: 'center',
                    filter: 'sepia(0.5) contrast(1.2) brightness(0.6)'
                }}
             ></div>
             
             <div className="z-10 flex flex-col items-center w-full max-w-4xl">
                <div 
                    className="mb-4 drop-shadow-[0_10px_20px_rgba(0,0,0,0.8)] animate-bounce-slight cursor-pointer hover:scale-105 transition-transform"
                    onClick={handleGodMode}
                    title="???"
                >
                   <TitleBadge className="w-32 h-32 md:w-48 md:h-48" />
                </div>

                <h1 className="text-5xl md:text-9xl text-transparent bg-clip-text bg-gradient-to-b from-yellow-300 to-red-600 drop-shadow-[0_5px_5px_rgba(0,0,0,1)] font-bold tracking-widest leading-none mb-4 font-['VT323'] whitespace-nowrap">
                  {t.title}
                </h1>
                <p className="text-sm md:text-2xl text-yellow-100 drop-shadow-md mb-8 tracking-wider bg-black/60 px-6 py-2 rounded-full border border-yellow-800/50">
                   {lang === window.Language.ZH ? 'EP1ï¼šå‹‡è€…èˆ‡æ¸…ç§€ä½³äººåœ¨æ„›å¾·è¯ç‹å­å³¶çš„å†’éšª' : 'EP1: The Adventure of the Hero and Anne on Prince Edward Island'}
                </p>

                <div className="flex flex-col items-center gap-4 w-64">
                  <RetroButton 
                      onClick={() => handleInput('ENTER')} 
                      active={titleSelection === 0}
                      onMouseEnter={() => setTitleSelection(0)}
                      className="justify-center text-2xl border-2 border-yellow-500 bg-black/80 hover:bg-red-900"
                  >
                      {t.start}
                  </RetroButton>

                  <RetroButton 
                      onClick={(e) => { e.stopPropagation(); setShowLoadMenu(true); audioService.playSfx('SELECT'); }} 
                      active={titleSelection === 1}
                      onMouseEnter={() => setTitleSelection(1)}
                      className={`justify-center text-xl border-2 border-blue-500 bg-black/80 hover:bg-blue-900 flex items-center gap-2 ${!hasSaves ? 'opacity-70' : ''}`}
                  >
                      {hasSaves && <span className="text-green-400 animate-pulse text-xs">â—</span>}
                      {t.continue}
                  </RetroButton>

                  <RetroButton 
                      onClick={(e) => { e.stopPropagation(); setShowApiKeyModal(true); audioService.playSfx('SELECT'); }} 
                      active={titleSelection === 2}
                      onMouseEnter={() => setTitleSelection(2)}
                      className="justify-center text-lg border-2 border-purple-500 bg-black/80 hover:bg-purple-900 flex items-center gap-2"
                  >
                      {hasApiKey ? "ğŸ”‘ API Configured" : "ğŸ”‘ Set API Key"}
                  </RetroButton>

                  <div className="flex gap-4 mt-4">
                      <button 
                      onClick={(e) => { e.stopPropagation(); setLang(window.Language.ZH); audioService.playSfx('SELECT'); }} 
                      className={`px-4 py-1 text-sm border ${lang===window.Language.ZH ? 'bg-yellow-600 text-white border-white' : 'bg-black/50 text-gray-400 border-gray-600'}`}
                      >
                      ä¸­æ–‡
                      </button>
                      <button 
                      onClick={(e) => { e.stopPropagation(); setLang(window.Language.EN); audioService.playSfx('SELECT'); }} 
                      className={`px-4 py-1 text-sm border ${lang===window.Language.EN ? 'bg-yellow-600 text-white border-white' : 'bg-black/50 text-gray-400 border-gray-600'}`}
                      >
                      EN
                      </button>
                  </div>
                </div>
             </div>
          </div>
        );
      };

      const WorldMapScreen = ({ player, t, currentScene, playerPos, mapMessage, handleMapClick, switchScene, dungeonProgress, onHeal }) => {
          const getCurrentMapData = () => {
              if (currentScene === 'CHARLOTTETOWN') return window.MAP_CHARLOTTETOWN;
              if (currentScene === 'CAVENDISH') return window.MAP_CAVENDISH;
              return window.MAP_AVONLEA;
          };

          const MAP_DATA = getCurrentMapData();
          const mapName = currentScene === 'AVONLEA' ? t.scenes.avonlea : (currentScene === 'CAVENDISH' ? t.scenes.cavendish : t.scenes.charlottetown);
          
          const showAvonlea = currentScene !== 'AVONLEA';
          const showCavendish = currentScene !== 'CAVENDISH' && dungeonProgress.avonlea.b2;
          const showCharlottetown = currentScene !== 'CHARLOTTETOWN' && dungeonProgress.cavendish.b2;
          
          const { TILE_COLORS, TILE_ICONS, PLAYER_SPRITE_URL } = window;

          return (
          <div className="flex flex-col md:flex-row h-full bg-black gap-2">
            <div className="w-full md:w-1/4 min-w-[200px] flex flex-col gap-2 order-1">
               <RetroWindow className="flex justify-between items-center py-2 bg-slate-900 border-slate-500">
                   <h2 className="text-base lg:text-xl text-yellow-300 tracking-wider flex items-center gap-2">
                       <span>ğŸ—ºï¸</span> {t.worldMapName}
                   </h2>
               </RetroWindow>
               <div className="flex-1">
                  <StatusPanel player={player} t={t} canHeal={true} onHeal={onHeal} />
               </div>
            </div>
            
            <div className="flex-1 flex flex-col bg-gray-900 overflow-hidden relative border-4 border-gray-700 rounded p-4 items-center justify-center order-2">
                <span className="absolute top-2 left-2 z-10 text-lg md:text-xl font-bold text-yellow-300 bg-black/50 px-3 py-1 border border-yellow-600 rounded">
                    {mapName}
                </span>
                <span className="absolute bottom-2 right-2 z-10 text-xs md:text-sm text-gray-300 animate-pulse bg-black/50 px-2 rounded">
                    {mapMessage || "Navigate with Arrow Keys or Click"}
                </span>
                
                <div className="absolute top-14 right-2 z-20 flex flex-col gap-2">
                    {showCharlottetown && (
                        <button onClick={() => switchScene('CHARLOTTETOWN')} className="bg-blue-800 text-white px-3 py-1 border border-white hover:bg-blue-600 text-xs md:text-sm font-bold shadow-lg">
                            âœˆ {t.scenes.charlottetown}
                        </button>
                    )}
                     {showCavendish && (
                        <button onClick={() => switchScene('CAVENDISH')} className="bg-purple-800 text-white px-3 py-1 border border-white hover:bg-purple-600 text-xs md:text-sm font-bold shadow-lg">
                            âœˆ {t.scenes.cavendish}
                        </button>
                    )}
                    {showAvonlea && (
                        <button onClick={() => switchScene('AVONLEA')} className="bg-green-800 text-white px-3 py-1 border border-white hover:bg-green-600 text-xs md:text-sm font-bold shadow-lg">
                            âœˆ {t.scenes.avonlea}
                        </button>
                    )}
                </div>

                <div 
                   className="grid gap-[1px] bg-black border-4 border-gray-600 shadow-2xl"
                   style={{ 
                       gridTemplateColumns: `repeat(${MAP_DATA[0].length}, minmax(0, 1fr))`,
                       width: '100%',
                       maxWidth: '800px',
                       aspectRatio: `${MAP_DATA[0].length}/${MAP_DATA.length}`
                   }}
                >
                    {MAP_DATA.map((row, y) => (
                        row.map((tile, x) => {
                            const isPlayerHere = x === playerPos.x && y === playerPos.y;
                            return (
                                <div 
                                    key={`${x}-${y}`}
                                    onClick={() => handleMapClick(x, y, 'WORLD')}
                                    className={`
                                      relative flex items-center justify-center text-sm md:text-3xl select-none cursor-pointer hover:brightness-110
                                      ${TILE_COLORS[tile]}
                                      transition-colors duration-300
                                    `}
                                >
                                    <span className="opacity-80 scale-75 md:scale-100 drop-shadow-md">{TILE_ICONS[tile]}</span>
                                    {isPlayerHere && (
                                        <div className="absolute inset-0 z-10 flex items-center justify-center pointer-events-none p-1">
                                            <div className="w-full h-full animate-bounce">
                                              <img 
                                                  src={PLAYER_SPRITE_URL} 
                                                  alt="Player" 
                                                  className="w-full h-full object-contain drop-shadow-[0_4px_4px_rgba(0,0,0,0.5)] scale-x-[-1]" 
                                              />
                                            </div>
                                        </div>
                                    )}
                                </div>
                            );
                        })
                    ))}
                </div>
            </div>
          </div>
          );
      };

      const TownScreen = ({ player, t, townPlayerPos, townMessage, activeShop, menuIndex, townNPCs, handleShopTransaction, handleMapClick, onHeal }) => {
          const { TOWN_MAP, TILE_COLORS, TILE_ICONS, PLAYER_SPRITE_URL, SHOP_IMAGES } = window;
          
          const getDist = (p1, p2) => {
              return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
          };

          const renderTownMap = () => (
              <div className="flex-1 flex flex-col bg-slate-900 overflow-hidden relative border-4 border-slate-700 rounded p-4 items-center justify-center order-2">
                  <div className="absolute top-2 left-2 right-2 z-20 flex justify-center pointer-events-none">
                       {townMessage && (
                          <div className="bg-black/80 border-2 border-white px-4 py-2 rounded-lg max-w-2xl animate-fade-in-up">
                              <span className="text-xl md:text-2xl text-yellow-300 font-bold leading-relaxed text-left block font-serif">
                                  {townMessage}
                              </span>
                          </div>
                       )}
                       {!townMessage && (
                          <span className="text-xs md:text-sm text-gray-300 bg-black/50 px-2 rounded self-center">
                              {t.town.welcome}
                          </span>
                       )}
                  </div>

                  <div 
                      className="grid gap-[1px] bg-black border-4 border-slate-500 shadow-2xl mt-8"
                      style={{ 
                          gridTemplateColumns: `repeat(${TOWN_MAP[0].length}, minmax(0, 1fr))`,
                          width: '100%',
                          maxWidth: '800px',
                          aspectRatio: `${TOWN_MAP[0].length}/${TOWN_MAP.length}`
                      }}
                  >
                      {TOWN_MAP.map((row, y) => (
                          row.map((tile, x) => {
                              const isPlayerHere = x === townPlayerPos.x && y === townPlayerPos.y;
                              const npc = townNPCs.find(n => n.x === x && n.y === y);

                              return (
                                  <div 
                                      key={`${x}-${y}`}
                                      onClick={() => handleMapClick(x, y, 'TOWN')}
                                      className={`
                                          relative flex items-center justify-center text-sm md:text-3xl select-none cursor-pointer hover:brightness-110
                                          ${TILE_COLORS[tile]}
                                      `}
                                  >
                                      <span className="opacity-90 scale-75 md:scale-100 drop-shadow-md">{TILE_ICONS[tile]}</span>
                                      {npc && (
                                          <div className="absolute inset-0 z-10 flex items-center justify-center pointer-events-none">
                                              <img 
                                                  src={`https://api.dicebear.com/9.x/notionists/svg?seed=${npc.avatarSeed}`}
                                                  alt={npc.name}
                                                  className="w-3/4 h-3/4 object-contain"
                                              />
                                              {getDist({x,y}, townPlayerPos) <= 1 && (
                                                  <div className="absolute -top-1 -right-1 bg-white text-black text-[8px] px-1 rounded-full animate-bounce">ğŸ’¬</div>
                                              )}
                                              {npc.reward && !npc.rewardClaimed && (
                                                   <div className="absolute top-0 left-0 text-[10px] animate-pulse">âœ¨</div>
                                              )}
                                          </div>
                                      )}
                                      {isPlayerHere && (
                                          <div className="absolute inset-0 z-20 flex items-center justify-center pointer-events-none p-1">
                                              <div className="w-full h-full animate-bounce">
                                                  <img 
                                                      src={PLAYER_SPRITE_URL} 
                                                      alt="Player" 
                                                      className="w-full h-full object-contain drop-shadow-[0_4px_4px_rgba(0,0,0,0.5)] scale-x-[-1]" 
                                                  />
                                              </div>
                                          </div>
                                      )}
                                  </div>
                              );
                          })
                      ))}
                  </div>
              </div>
          );

          const renderShop = () => {
              let shopName = "";
              let npcImage = "";
              let actionText = "";

              if (activeShop === 'GUILD') { shopName = t.town.shops.guild; npcImage = SHOP_IMAGES.guild; actionText = t.town.actions.rest(20); }
              if (activeShop === 'WEAPON') { shopName = t.town.shops.weapon; npcImage = SHOP_IMAGES.weapon; actionText = t.town.actions.buyWeapon(100 * player.level); }
              if (activeShop === 'ARMOR') { shopName = t.town.shops.armor; npcImage = SHOP_IMAGES.armor; actionText = t.town.actions.buyArmor(100 * player.level); }
              if (activeShop === 'ITEM') { shopName = t.town.shops.item; npcImage = SHOP_IMAGES.item; actionText = t.town.actions.buyPotion(20); }
              if (activeShop === 'MAGIC') { shopName = t.town.shops.magic; npcImage = SHOP_IMAGES.magic; actionText = t.town.actions.buyMagic(200 * player.level); }

              return (
                  <div className="flex-1 relative flex flex-col border-4 border-yellow-700 rounded overflow-hidden bg-[#2a1d15] order-2">
                       <div className="flex-1 flex flex-col items-center justify-center p-4 md:p-8">
                            <div className="bg-black/50 border-4 border-yellow-600 rounded-full p-2 mb-4 md:mb-6 shadow-2xl">
                                <img 
                                  src={npcImage} 
                                  alt="Shop Keeper" 
                                  className="w-24 h-24 md:w-48 md:h-48 rounded-full object-cover bg-gray-800"
                                />
                            </div>
                            
                            <RetroWindow className="w-full max-w-lg mb-4 md:mb-8 bg-black/80 border-yellow-500">
                                  <h2 className="text-xl md:text-3xl text-yellow-400 text-center border-b border-gray-600 pb-2 mb-2">{shopName}</h2>
                                  <p className="text-center text-white text-sm md:text-lg italic">"{townMessage || t.town.welcome}"</p>
                            </RetroWindow>
                            
                            <div className="w-full max-w-md space-y-4">
                                <RetroButton 
                                  active={menuIndex === 0}
                                  onClick={() => handleShopTransaction(0)}
                                  className="bg-blue-900/90 border-blue-400 py-2 md:py-4 text-sm md:text-xl"
                                >
                                  {activeShop === 'ITEM' && <span className="mr-2 text-red-500">ğŸ”´</span>}
                                  {actionText}
                                </RetroButton>
                                <RetroButton 
                                  active={menuIndex === 1}
                                  onClick={() => handleShopTransaction(1)}
                                  className="bg-red-900/90 border-red-400 py-2 md:py-4 text-sm md:text-xl"
                                >
                                  {t.town.actions.leave}
                                </RetroButton>
                            </div>
                       </div>
                  </div>
              );
          };

          return (
              <div className="flex flex-col md:flex-row h-full bg-black gap-2">
                   <div className="w-full md:w-1/4 min-w-[200px] flex flex-col gap-2 order-1">
                      <RetroWindow className="flex justify-between items-center py-2 bg-slate-900 border-slate-500">
                           <h2 className="text-base lg:text-xl text-yellow-300 tracking-wider flex items-center gap-2">
                               <span>ğŸ°</span> {t.locations.castle}
                           </h2>
                      </RetroWindow>
                      <div className="flex-1">
                        <StatusPanel player={player} t={t} canHeal={true} onHeal={onHeal} />
                      </div>
                   </div>
                   {activeShop ? renderShop() : renderTownMap()}
              </div>
          );
      };

      const DungeonScreen = ({ player, t, dungeonFloor, dungeonPlayerPos, dungeonProgress, exploreLog, currentScene, handleMapClick, onHeal }) => {
          const { DUNGEON_B1_MAP, DUNGEON_B2_MAP, TILE_COLORS, TILE_ICONS, LOCATION_IMAGES, PLAYER_SPRITE_URL } = window;
          
          const getDungeonMap = () => {
              return dungeonFloor === 1 ? DUNGEON_B1_MAP : DUNGEON_B2_MAP;
          };

          const dMap = getDungeonMap();
          
          let cleared = false;
          if (currentScene === 'AVONLEA') {
              cleared = dungeonFloor === 1 ? dungeonProgress.avonlea.b1 : dungeonProgress.avonlea.b2;
          } else if (currentScene === 'CAVENDISH') {
              cleared = dungeonFloor === 1 ? dungeonProgress.cavendish.b1 : dungeonProgress.cavendish.b2;
          } else if (currentScene === 'CHARLOTTETOWN') {
              cleared = dungeonFloor === 1 ? dungeonProgress.charlottetown.b1 : dungeonProgress.charlottetown.b2;
          }

          return (
            <div className="flex flex-col md:flex-row h-full bg-slate-900 gap-2">
                <div className="w-full md:w-1/4 min-w-[220px] flex flex-col gap-2 order-1">
                     <RetroWindow className="bg-blue-900/50 border-blue-400 flex flex-row items-center justify-center p-2 gap-4">
                          <span className="text-3xl">ğŸ’€</span>
                          <h2 className="text-xl text-blue-300 animate-pulse whitespace-nowrap">
                              {t.dungeon.floor(dungeonFloor)}
                          </h2>
                     </RetroWindow>

                     <div className="flex-1">
                       <StatusPanel player={player} t={t} canHeal={true} onHeal={onHeal} />
                     </div>
                </div>

                <div className="flex-1 flex flex-col bg-black overflow-hidden relative border-4 border-blue-800 rounded p-4 items-center justify-center order-2">
                    <div 
                        className="absolute inset-0 opacity-20 pointer-events-none"
                        style={{ backgroundImage: `url("${LOCATION_IMAGES.volcano}")`, backgroundSize: 'cover' }}
                    ></div>
                    
                    <span className="absolute top-2 left-2 z-10 text-lg font-bold text-blue-300 bg-black/50 px-3 py-1 border border-blue-600 rounded">
                       {exploreLog || t.dungeon.title}
                    </span>

                    <div 
                        className="grid gap-[1px] bg-black border-4 border-blue-900 shadow-2xl z-10"
                        style={{ 
                            gridTemplateColumns: `repeat(${dMap[0].length}, minmax(0, 1fr))`,
                            width: '100%',
                            maxWidth: '800px',
                            aspectRatio: `${dMap[0].length}/${dMap.length}`
                        }}
                    >
                        {dMap.map((row, y) => (
                            row.map((tile, x) => {
                                const isPlayerHere = x === dungeonPlayerPos.x && y === dungeonPlayerPos.y;
                                
                                let displayTile = tile;
                                if (tile === 'B' && cleared) {
                                    displayTile = dungeonFloor === 1 ? 'S' : 'E';
                                }

                                return (
                                    <div 
                                        key={`${x}-${y}`}
                                        onClick={() => handleMapClick(x, y, 'DUNGEON')}
                                        className={`
                                          relative flex items-center justify-center text-sm md:text-3xl select-none cursor-pointer hover:brightness-110
                                          ${TILE_COLORS[displayTile]}
                                        `}
                                    >
                                        <span className="opacity-90 scale-75 md:scale-100 drop-shadow-md">{TILE_ICONS[displayTile]}</span>
                                        {isPlayerHere && (
                                            <div className="absolute inset-0 z-10 flex items-center justify-center pointer-events-none p-1">
                                                <div className="w-full h-full animate-bounce">
                                                    <img 
                                                        src={PLAYER_SPRITE_URL} 
                                                        alt="Player" 
                                                        className="w-full h-full object-contain drop-shadow-[0_4px_4px_rgba(0,0,0,0.5)] scale-x-[-1]" 
                                                    />
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                );
                            })
                        ))}
                    </div>
                </div>
            </div>
          );
      };

      const BattleScreen = ({ 
          player, enemy, t, battleState, battleLogs, menuIndex, 
          handlePlayerAction, selectedLocation, currentScene, dungeonFloor, scrollRef
      }) => {
          const { BattleState, LOCATION_IMAGES } = window;
          
          const getMonsterLevelColorClass = (level) => {
              let min = 1;
              let max = 8;
              let additive = 0;
              
              if (currentScene === 'CAVENDISH') additive = 5;
              if (currentScene === 'CHARLOTTETOWN') additive = 10;
              
              const rankBonus = player.reincarnationCount * 2;
              
              const isDungeon = dungeonFloor !== undefined;

              if (isDungeon) {
                  if (dungeonFloor === 1) {
                      min = 5; max = 9;
                  } else {
                      min = 8; max = 10;
                  }
              } else {
                  min = 1; max = 8;
              }
        
              min += additive + rankBonus;
              max += additive + rankBonus;
        
              const range = max - min;
              const oneThird = range / 3;
              
              const weakThreshold = min + oneThird;
              const strongThreshold = max - oneThird;
        
              if (level <= weakThreshold) return "text-green-400";
              if (level >= strongThreshold) return "text-orange-400";
              return "text-yellow-200";
          };

          // Handle Loading State or Null Enemy gracefully
          const isLoading = !enemy || battleState === BattleState.LOADING;
          const levelColorClass = enemy ? getMonsterLevelColorClass(enemy.level) : "text-gray-400";

          return (
            <div 
                className="flex flex-col md:flex-row h-full bg-red-950 gap-2 select-none"
                onClick={() => {
                     // Global click handler to advance state on Victory/Defeat
                     if (battleState === BattleState.VICTORY || battleState === BattleState.DEFEAT) {
                         handlePlayerAction('DUMMY_CLICK'); 
                     }
                }}
            >
                {/* Left Sidebar: Hero Status */}
                <div className="w-full md:w-1/4 min-w-[200px] flex flex-col gap-2 order-1 p-2 bg-black/20">
                     <RetroWindow className="bg-red-900 border-red-500 py-2 text-center">
                          <h2 className="text-xl text-yellow-300 tracking-wider">âš”ï¸ BATTLE</h2>
                     </RetroWindow>
                     <div className="flex-1">
                        <StatusPanel player={player} t={t} canHeal={false} />
                     </div>
                </div>

                {/* Right Main Area */}
                <div className="flex-1 flex flex-col relative p-2 order-2 overflow-hidden border-l-4 border-red-900 gap-2">
                    <div 
                        className="absolute inset-0 opacity-30 z-0 pointer-events-none" 
                        style={{ 
                            backgroundImage: `url("${LOCATION_IMAGES[selectedLocation || 'castle']}")`,
                            backgroundSize: 'cover',
                            backgroundPosition: 'center',
                            filter: 'grayscale(0.5) contrast(1.2)'
                        }}
                    ></div>

                    {/* Top Area: Monster (Split 50/50) */}
                    <div className="flex-1 flex flex-row gap-2 z-10 min-h-0">
                        {/* Left: Monster Image */}
                        <div className="w-1/2 flex justify-center items-center relative">
                            {isLoading ? (
                                <div className="text-yellow-300 animate-pulse text-2xl font-bold tracking-widest text-shadow-retro text-center">
                                    {t.loading}
                                </div>
                            ) : (
                                <div className={`relative transition-transform duration-500 ${battleState === BattleState.PROCESSING ? 'scale-110' : 'scale-100'}`}>
                                    {enemy.isBoss && <div className="absolute -top-10 left-1/2 -translate-x-1/2 text-red-500 font-bold text-2xl animate-pulse whitespace-nowrap text-shadow-retro">âš  BOSS âš </div>}
                                    <img 
                                        src={enemy.imageUrl} 
                                        alt={enemy.name} 
                                        className={`
                                            max-w-full max-h-[200px] md:max-h-[300px] object-contain drop-shadow-[0_0_15px_rgba(255,0,0,0.5)]
                                            ${battleState === BattleState.DEFEAT ? 'grayscale opacity-50' : ''}
                                            ${battleState === BattleState.VICTORY ? 'opacity-0 scale-0 rotate-180 transition-all duration-1000' : ''}
                                        `}
                                    />
                                    {/* Victory Text Overlay */}
                                    {battleState === BattleState.VICTORY && (
                                        <div className="absolute inset-0 flex items-center justify-center z-50 animate-victory-pop">
                                            <h1 className="text-6xl md:text-8xl font-black text-transparent bg-clip-text bg-gradient-to-b from-yellow-300 via-orange-500 to-red-600 animate-pulse-glow whitespace-nowrap" style={{textShadow: '4px 4px 0px #000'}}>
                                                VICTORY!
                                            </h1>
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>

                        {/* Right: Monster Info */}
                        <div className="w-1/2 h-full">
                            <RetroWindow className="h-full bg-red-900/80 border-red-500 flex flex-col overflow-hidden">
                                 {isLoading ? (
                                    <div className="flex items-center justify-center h-full text-gray-400">...</div>
                                 ) : (
                                   <>
                                     {/* Level & Name */}
                                     <div className="border-b border-red-400 pb-2 mb-2 flex-shrink-0">
                                        <div className={`text-2xl font-bold ${levelColorClass} text-shadow-retro`}>LV.{enemy.level}</div>
                                        <div className="text-3xl text-white font-bold text-shadow-retro leading-none mt-1">{enemy.name}</div>
                                     </div>
                                     
                                     {/* Stats Grid */}
                                     <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-sm md:text-base mb-2 flex-shrink-0 text-shadow-retro">
                                        <div className="text-red-200">{t.hp}: {enemy.hp}/{enemy.maxHp}</div>
                                        <div className="text-blue-200">{t.mp}: {enemy.mp}/{enemy.maxMp}</div>
                                        <div className="text-yellow-200">{t.atk}: {enemy.attack}</div>
                                        <div className="text-gray-200">{t.def}: {enemy.defense}</div>
                                     </div>
                                     
                                     {/* HP Bar */}
                                     <div className="w-full bg-gray-800 h-2 rounded-full mb-3 flex-shrink-0">
                                        <div className="bg-red-500 h-full transition-all duration-500" style={{ width: `${(enemy.hp / enemy.maxHp) * 100}%` }}></div>
                                     </div>

                                     {/* Description */}
                                     <div className="flex-1 bg-black/20 p-2 rounded text-base md:text-lg leading-snug text-gray-100 italic overflow-y-auto text-shadow-retro">
                                         {enemy.description}
                                     </div>
                                   </>
                                 )}
                            </RetroWindow>
                        </div>
                    </div>

                    {/* Bottom Area: Controls & Logs */}
                    <div className="h-1/3 min-h-[160px] flex flex-row gap-2 z-10 w-full">
                        {/* Left: Commands */}
                        <RetroWindow className="w-1/2 bg-blue-900 border-white flex flex-col justify-center" title="Command">
                             {!isLoading && battleState === BattleState.PLAYER_INPUT ? (
                                 <div className="flex flex-col gap-1 overflow-y-auto max-h-full">
                                    <RetroButton active={menuIndex === 0} onClick={(e) => { e.stopPropagation(); handlePlayerAction('PHYSICAL'); }}>{t.cmdPhysical}</RetroButton>
                                    <RetroButton active={menuIndex === 1} onClick={(e) => { e.stopPropagation(); handlePlayerAction('MAG_ATK'); }}>{t.cmdMagAtk}</RetroButton>
                                    <RetroButton active={menuIndex === 2} onClick={(e) => { e.stopPropagation(); handlePlayerAction('MAG_HEAL'); }}>{t.cmdMagHeal}</RetroButton>
                                    <RetroButton active={menuIndex === 3} onClick={(e) => { e.stopPropagation(); handlePlayerAction('ITEM'); }}>{t.cmdItem} ({player.potions})</RetroButton>
                                    <RetroButton active={menuIndex === 4} onClick={(e) => { e.stopPropagation(); handlePlayerAction('FLEE'); }}>{t.cmdFlee}</RetroButton>
                                 </div>
                             ) : (
                                 <div className="text-center text-gray-400 animate-pulse text-xl">
                                     {isLoading ? "..." : (battleState === BattleState.PROCESSING ? "..." : (battleState === BattleState.VICTORY ? "" : "DEFEAT"))}
                                 </div>
                             )}
                        </RetroWindow>

                        {/* Right: Logs */}
                        <RetroWindow className="w-1/2 bg-black/80 border-white flex flex-col" title="Battle Log">
                             <div className="flex-1 overflow-y-auto min-h-0 p-1" ref={scrollRef}>
                                 <div className="space-y-1 text-sm md:text-lg text-shadow-retro pb-2">
                                     {battleLogs.map((log, i) => (
                                         <div key={i} className="animate-fade-in-up border-b border-gray-800 pb-1 last:border-0">
                                             <span className="text-green-400 mr-2">â¤</span>{log}
                                         </div>
                                     ))}
                                     {battleState === BattleState.VICTORY && (
                                         <div className="text-yellow-400 font-bold text-center mt-4 animate-bounce">
                                             PRESS ENTER OR CLICK TO CONTINUE
                                         </div>
                                     )}
                                      {battleState === BattleState.DEFEAT && (
                                         <div className="text-red-500 font-bold text-center mt-4 animate-bounce">
                                             PRESS ENTER OR CLICK...
                                         </div>
                                     )}
                                 </div>
                             </div>
                        </RetroWindow>
                    </div>
                </div>
            </div>
          );
      };

      const App = () => {
        // Destructure Globals for cleaner code
        const { 
            Language, GameState, BattleState, TRANSLATIONS, 
            INITIAL_PLAYER, ENCOUNTER_RATES, 
            MAP_AVONLEA, MAP_CAVENDISH, MAP_CHARLOTTETOWN, TOWN_MAP, 
            DUNGEON_B1_MAP, DUNGEON_B2_MAP, MAP_START_POS, TOWN_START_POS, 
            DUNGEON_START_POS, LOOT_NAMES, NPC_DIALOGUES, NPC_NAMES
        } = window;

        const { audioService, generateDinosaur } = window;
        const { VirtualPad } = window;

        const [lang, setLang] = useState(Language.ZH);
        const [gameState, setGameState] = useState(GameState.TITLE);
        const [prevGameState, setPrevGameState] = useState(GameState.MAP);
        const [player, setPlayer] = useState({ ...INITIAL_PLAYER });
        const [enemy, setEnemy] = useState(null);
        const [battleLogs, setBattleLogs] = useState([]);
        const [battleState, setBattleState] = useState(BattleState.PLAYER_INPUT);
        const [menuIndex, setMenuIndex] = useState(0);
        const [titleSelection, setTitleSelection] = useState(0); 
        const [loading, setLoading] = useState(false);
        const [isMuted, setIsMuted] = useState(false);
        const [playerNameInput, setPlayerNameInput] = useState("");
        const [showSaveMenu, setShowSaveMenu] = useState(false);
        const [showLoadMenu, setShowLoadMenu] = useState(false);
        const [saveMessage, setSaveMessage] = useState("");
        const [notification, setNotification] = useState("");
        const [hasSaves, setHasSaves] = useState(false);
        const [showAboutModal, setShowAboutModal] = useState(false);
        const [showApiKeyModal, setShowApiKeyModal] = useState(false);
        const [hasApiKey, setHasApiKey] = useState(false);
        const [showReincarnationModal, setShowReincarnationModal] = useState(false);
        const [pendingReincarnationPlayer, setPendingReincarnationPlayer] = useState(null);
        const [currentScene, setCurrentScene] = useState('AVONLEA');
        const [playerPos, setPlayerPos] = useState({ x: MAP_START_POS.x, y: MAP_START_POS.y });
        const [mapMessage, setMapMessage] = useState("");
        const [townPlayerPos, setTownPlayerPos] = useState({ x: TOWN_START_POS.x, y: TOWN_START_POS.y });
        const [activeShop, setActiveShop] = useState(null);
        const [townMessage, setTownMessage] = useState("");
        const [townNPCs, setTownNPCs] = useState([]);
        const [dungeonFloor, setDungeonFloor] = useState(1);
        const [dungeonPlayerPos, setDungeonPlayerPos] = useState({ x: DUNGEON_START_POS.x, y: DUNGEON_START_POS.y });
        const [dungeonProgress, setDungeonProgress] = useState({ 
            avonlea: { b1: false, b2: false },
            cavendish: { b1: false, b2: false },
            charlottetown: { b1: false, b2: false }
        });
        const [selectedLocation, setSelectedLocation] = useState(null);
        const [exploreLog, setExploreLog] = useState("");
        const [inputCooldown, setInputCooldown] = useState(false);
        const academyTimer = useRef(0);
        const t = TRANSLATIONS[lang];
        const scrollRef = useRef(null);
        
        const getCurrentMapData = () => {
          if (currentScene === 'CHARLOTTETOWN') return MAP_CHARLOTTETOWN;
          if (currentScene === 'CAVENDISH') return MAP_CAVENDISH;
          return MAP_AVONLEA;
        };

        const getDungeonMap = () => {
            return dungeonFloor === 1 ? DUNGEON_B1_MAP : DUNGEON_B2_MAP;
        }

        const handleUserInteraction = () => {
          if (gameState === GameState.BATTLE && (battleState === BattleState.VICTORY || battleState === BattleState.DEFEAT)) {
              handleInput('ENTER');
          }
          audioService.init().catch(console.error);
        };

        const checkSaves = () => {
          const slots = [];
          for(let i=1; i<=5; i++) {
                const data = localStorage.getItem(`turkey_quest_save_${i}`);
                slots.push(data);
          }
          if (slots.some(s => s !== null)) {
              setHasSaves(true);
          }
        };

        useEffect(() => {
          checkSaves();
          const storedKey = localStorage.getItem('gemini_api_key');
          if (storedKey) setHasApiKey(true);
        }, []);

        useEffect(() => {
          if (scrollRef.current) {
            scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
          }
        }, [battleLogs]);

        useEffect(() => {
          if (gameState === GameState.TITLE || gameState === GameState.NAME_INPUT) {
              audioService.playBgm('TITLE');
          } else if (gameState === GameState.MAP || gameState === GameState.TOWN) {
              audioService.playBgm('MAP');
          } else if (gameState === GameState.BATTLE || gameState === GameState.DUNGEON) {
              audioService.playBgm('BATTLE');
          } else {
              audioService.stopBgm();
          }
        }, [gameState]);

        const initTownNPCs = useCallback(() => {
          const newNPCs = [];
          const seedBase = Date.now();
          const npcCount = 5; 
          const rewardIndex = Math.floor(Math.random() * npcCount); 

          for (let i = 0; i < npcCount; i++) {
             let rx = 0, ry = 0;
             do {
                 rx = Math.floor(Math.random() * TOWN_MAP[0].length);
                 ry = Math.floor(Math.random() * TOWN_MAP.length);
             } while (TOWN_MAP[ry][rx] !== 'R');

             const dialogueList = NPC_DIALOGUES;
             const dialogue = dialogueList[Math.floor(Math.random() * dialogueList.length)];
             const name = NPC_NAMES[Math.floor(Math.random() * NPC_NAMES.length)];

             let reward = undefined;
             if (i === rewardIndex) {
                 const roll = Math.random();
                 if (roll < 0.4) reward = { type: 'GOLD', value: Math.floor(Math.random() * 50) + 50 }; 
                 else if (roll < 0.7) reward = { type: 'POTION', value: 1 }; 
                 else if (roll < 0.85) reward = { type: 'MAXHP', value: 1 };
                 else reward = { type: 'MAXMP', value: 1 }; 
             }

             newNPCs.push({
                 id: i,
                 x: rx,
                 y: ry,
                 avatarSeed: `NPC_${seedBase}_${i}`,
                 name,
                 dialogue,
                 reward: reward,
                 rewardClaimed: false
             });
          }
          setTownNPCs(newNPCs);
        }, [currentScene]);

        useEffect(() => {
            if (gameState !== GameState.TOWN || activeShop) return;

            const interval = setInterval(() => {
                setTownNPCs(prev => prev.map(npc => {
                    if (Math.random() > 0.6) return npc; 

                    const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                    const move = dirs[Math.floor(Math.random() * dirs.length)];
                    const nx = npc.x + move[0];
                    const ny = npc.y + move[1];

                    if (ny >= 0 && ny < TOWN_MAP.length && nx >= 0 && nx < TOWN_MAP[0].length) {
                        if (TOWN_MAP[ny][nx] === 'R') {
                            return { ...npc, x: nx, y: ny };
                        }
                    }
                    return npc;
                }));
            }, 1500);

            return () => clearInterval(interval);
        }, [gameState, activeShop]);

        useEffect(() => {
          if (gameState !== GameState.MAP) {
              academyTimer.current = 0; 
              return;
          }

          const interval = setInterval(() => {
              const mapData = getCurrentMapData();
              const tile = mapData[playerPos.y][playerPos.x];

              if (tile === 'H' && (player.hp < player.maxHp || player.mp < player.maxMp)) {
                   setPlayer((p) => ({
                       ...p,
                       hp: Math.min(p.maxHp, p.hp + 1),
                       mp: Math.min(p.maxMp, p.mp + 1)
                   }));
              }

              if (tile === 'K') {
                  setPlayer((p) => ({ ...p, gold: p.gold + 10 }));
              }

              if (tile === 'U') {
                  academyTimer.current += 1;
                  if (academyTimer.current >= 5) {
                      setPlayer((p) => ({ ...p, potions: p.potions + 1 }));
                      academyTimer.current = 0;
                  }
              } else {
                  academyTimer.current = 0;
              }
              
          }, 1000);

          return () => clearInterval(interval);
        }, [gameState, playerPos, player, currentScene]);

        const getVisualLength = (str) => {
            let len = 0;
            for (let i = 0; i < str.length; i++) {
                if (str.charCodeAt(i) > 255) len += 2;
                else len += 1;
            }
            return len;
        };

        const handleNameChange = (e) => {
            const newVal = e.target.value;
            if (getVisualLength(newVal) <= 10) {
                setPlayerNameInput(newVal);
            }
        };

        const submitName = () => {
            audioService.playSfx('CONFIRM');
            const finalName = playerNameInput.trim() || t.naming.defaultName;
            setPlayer({ ...INITIAL_PLAYER, name: finalName });
            setGameState(GameState.MAP);
            setCurrentScene('AVONLEA');
            setPlayerPos(MAP_START_POS); 
            setDungeonFloor(1);
            setDungeonProgress({ 
                avonlea: { b1: false, b2: false },
                cavendish: { b1: false, b2: false },
                charlottetown: { b1: false, b2: false }
            });
            setMapMessage(t.dungeon.title);
        };

        const createSaveData = (overridePlayer) => {
            let sceneName = "";
            if (currentScene === 'AVONLEA') sceneName = t.scenes.avonlea.split('. ')[1];
            else if (currentScene === 'CAVENDISH') sceneName = t.scenes.cavendish.split('. ')[1];
            else if (currentScene === 'CHARLOTTETOWN') sceneName = t.scenes.charlottetown.split('. ')[1];

            const locationLabel = gameState === GameState.DUNGEON 
              ? `${t.dungeon.floor(dungeonFloor)} - ${sceneName}` 
              : (gameState === GameState.TOWN ? t.town.welcome.split(' ')[2] || 'Town' : (currentScene === 'AVONLEA' ? t.scenes.avonlea : (currentScene === 'CAVENDISH' ? t.scenes.cavendish : t.scenes.charlottetown)));

            return {
                player: overridePlayer || player,
                currentScene,
                playerPos,
                townPlayerPos,
                dungeonFloor,
                dungeonPlayerPos,
                dungeonProgress,
                timestamp: Date.now(),
                locationLabel
            };
        };

        const performSave = (slotIndex, data) => {
            localStorage.setItem(`turkey_quest_save_${slotIndex + 1}`, JSON.stringify(data));
            setHasSaves(true);
        };

        const saveGame = (slotIndex) => {
            performSave(slotIndex, createSaveData());
            audioService.playSfx('WIN');
            setSaveMessage(t.saveLoad.savedMsg);
            setTimeout(() => {
                setSaveMessage("");
                setShowSaveMenu(false);
            }, 1000);
        };

        const autoSaveGame = (currentPlayerState) => {
            const data = createSaveData(currentPlayerState);
            performSave(4, data);
            addLog(t.saveLoad.autoSavedLog);
        };

        const loadGame = (slotIndex) => {
            const dataStr = localStorage.getItem(`turkey_quest_save_${slotIndex + 1}`);
            if (!dataStr) return;
            
            const data = JSON.parse(dataStr);
            setPlayer(data.player);
            setCurrentScene(data.currentScene);
            setPlayerPos(data.playerPos);
            setTownPlayerPos(data.townPlayerPos);
            setDungeonFloor(data.dungeonFloor);
            setDungeonPlayerPos(data.dungeonPlayerPos || DUNGEON_START_POS);
            if (!data.dungeonProgress.avonlea) {
                setDungeonProgress({ 
                    avonlea: { b1: false, b2: false },
                    cavendish: { b1: false, b2: false },
                    charlottetown: { b1: false, b2: false }
                });
            } else {
                setDungeonProgress(data.dungeonProgress);
            }
            
            if (data.dungeonFloor > 0 && data.locationLabel.includes('B')) {
                setGameState(GameState.DUNGEON); 
            } else if (data.locationLabel.includes('Town') || data.locationLabel.includes('å ¡å£˜')) {
                setGameState(GameState.TOWN);
            } else {
                setGameState(GameState.MAP);
            }

            setMapMessage(t.saveLoad.loadedMsg);
            audioService.playSfx('CONFIRM');
            setShowLoadMenu(false);
        };

        const addLog = (msg) => {
          setBattleLogs(prev => [...prev.slice(-4), msg]);
        };

        const getDist = (p1, p2) => {
            return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
        };

        const findTileLocation = (mapData, tileChar) => {
            for(let y=0; y<mapData.length; y++) {
                for(let x=0; x<mapData[0].length; x++) {
                    if (mapData[y][x] === tileChar) return {x, y};
                }
            }
            return null;
        };

        const calculateEncounterLevel = (isBoss, mapData, currentPos) => {
          let sceneMin = 1;
          let sceneMax = 8;
          
          let additive = 0;
          if (currentScene === 'CAVENDISH') additive = 5;
          if (currentScene === 'CHARLOTTETOWN') additive = 10;

          const rankBonus = player.reincarnationCount * 2;
          sceneMin += additive + rankBonus;
          sceneMax += additive + rankBonus;

          if (gameState === GameState.DUNGEON) {
              if (dungeonFloor === 1) { return Math.floor(Math.random() * ((9 + additive + rankBonus) - (5 + additive + rankBonus) + 1)) + (5 + additive + rankBonus); } 
              if (dungeonFloor === 2) { return Math.floor(Math.random() * ((10 + additive + rankBonus) - (8 + additive + rankBonus) + 1)) + (8 + additive + rankBonus); } 
              
              if (isBoss) {
                  const baseBossLvl = dungeonFloor === 1 ? 10 : 15;
                  return baseBossLvl + additive + rankBonus;
              }
          } 

          const totalRange = sceneMax - sceneMin;
          const oneThird = totalRange / 3;
          
          const lowEndMax = Math.floor(sceneMin + oneThird);
          const highEndMin = Math.ceil(sceneMin + (oneThird * 2));

          const townLoc = findTileLocation(mapData, 'C');
          if (townLoc && getDist(currentPos, townLoc) <= 5) {
              return Math.floor(Math.random() * (lowEndMax - sceneMin + 1)) + sceneMin;
          }

          const dungeonLocV = findTileLocation(mapData, 'V');
          if (dungeonLocV && getDist(currentPos, dungeonLocV) <= 3) {
               return Math.floor(Math.random() * (sceneMax - highEndMin + 1)) + highEndMin;
          }

          const midMin = lowEndMax + 1;
          const midMax = highEndMin - 1;
          
          if (midMin > midMax) return Math.floor(sceneMin + (totalRange/2)); 
          return Math.floor(Math.random() * (midMax - midMin + 1)) + midMin;
        };

        const startBattle = async (isBoss = false) => {
          // Immediately enter battle view state to avoid black screen
          setPrevGameState(gameState);
          setGameState(GameState.BATTLE);
          setBattleState(BattleState.LOADING);
          setEnemy(null);
          setBattleLogs([]);
          setMenuIndex(0);
          
          audioService.playSfx(isBoss ? 'LOSE' : 'CONFIRM'); 
          setLoading(true);
          
          const mapData = getCurrentMapData();
          let currentTile = 'G'; 
          
          if (gameState === GameState.MAP) {
               currentTile = mapData[playerPos.y][playerPos.x];
          }

          if (gameState === GameState.DUNGEON) setSelectedLocation('volcano');
          else if (currentTile === 'F') setSelectedLocation('forest');
          else if (currentTile === 'M') setSelectedLocation('mountain');
          else if (currentTile === 'C') setSelectedLocation('castle');
          else setSelectedLocation('castle');

          const targetLevel = calculateEncounterLevel(isBoss, mapData, playerPos);

          const newEnemy = await generateDinosaur(targetLevel, lang);
          
          if (isBoss) {
              newEnemy.isBoss = true;
              newEnemy.name = `BOSS: ${newEnemy.name}`;
              newEnemy.hp = Math.floor(newEnemy.hp * 1.5);
              newEnemy.maxHp = newEnemy.hp; // Fix: Sync maxHp with boosted Hp
              newEnemy.attack = Math.floor(newEnemy.attack * 1.2);
          }
          
          setEnemy(newEnemy);
          addLog(t.enemyAppears(newEnemy.name));
          setBattleState(BattleState.PLAYER_INPUT);
          setLoading(false);
        };

        const checkRandomEncounter = (tile) => {
          if (['C', 'V', 'H', 'K', 'U', 'W', '_', 'S', 'E', 'B', 'g', 'w', 'a', 'i', 'm', 'N', 'd'].includes(tile)) return false; 

          const rate = ENCOUNTER_RATES[tile] || 0.1;
          let finalRate = rate;
          
          if (gameState === GameState.DUNGEON) finalRate = 0.35;

          if (Math.random() < finalRate) {
             setMapMessage(t.dungeon.encounter);
             setTimeout(() => startBattle(false), 100);
             return true;
          }
          return false;
        };

        const handleFieldHeal = (type) => {
             let healAmount = 0;
             let newPlayer = {...player};
             let success = false;

             if (type === 'MAGIC') {
                 if (player.mp >= 3) {
                     healAmount = 20 + player.level * 5;
                     newPlayer.mp -= 3;
                     newPlayer.hp = Math.min(newPlayer.maxHp, newPlayer.hp + healAmount);
                     success = true;
                     setMapMessage(t.heal(healAmount));
                 } else {
                     setMapMessage(t.noMp);
                 }
             } else if (type === 'POTION') {
                 if (player.potions > 0) {
                     healAmount = 40;
                     newPlayer.potions -= 1;
                     newPlayer.hp = Math.min(newPlayer.maxHp, newPlayer.hp + healAmount);
                     success = true;
                     setMapMessage(t.itemUsed());
                 } else {
                     setMapMessage(t.noItem);
                 }
             }

             if (success) {
                 audioService.playSfx('HEAL');
                 setPlayer(newPlayer);
             } else {
                 audioService.playSfx('CANCEL');
             }
        };

        const handlePlayerAction = async (action) => {
          if (action === 'DUMMY_CLICK') {
              if (battleState === BattleState.VICTORY || battleState === BattleState.DEFEAT) {
                  handleInput('ENTER');
              }
              return;
          }

          if (!enemy || battleState !== BattleState.PLAYER_INPUT || loading) return;

          setBattleState(BattleState.PROCESSING);
          audioService.playSfx('SELECT');
          
          let playerDamage = 0;

          switch (action) {
            case 'PHYSICAL':
              playerDamage = Math.max(1, Math.floor(Math.random() * 5) + (13 + player.level * 2 + player.equipmentAtk) - enemy.defense);
              if (Math.random() > 0.9) playerDamage = Math.floor(playerDamage * 1.5);
              
              audioService.playSfx('ATTACK');
              setTimeout(() => audioService.playSfx('HIT'), 200);

              setEnemy((prev) => prev ? { ...prev, hp: Math.max(0, prev.hp - playerDamage) } : null);
              addLog(t.playerAttack(playerDamage));
              break;

            case 'MAG_ATK':
              if (player.mp >= 5) {
                  playerDamage = Math.floor(Math.random() * 10) + player.level * 4 + 10;
                  audioService.playSfx('CONFIRM'); 
                  setTimeout(() => audioService.playSfx('HIT'), 300);

                  setPlayer((prev) => ({ ...prev, mp: prev.mp - 5 }));
                  setEnemy((prev) => prev ? { ...prev, hp: Math.max(0, prev.hp - playerDamage) } : null);
                  addLog(t.playerMagAtk(playerDamage));
              } else {
                  audioService.playSfx('CANCEL');
                  addLog(t.noMp);
                  setBattleState(BattleState.PLAYER_INPUT);
                  return;
              }
              break;

            case 'MAG_HEAL':
              if (player.mp >= 3) {
                const healAmount = 20 + player.level * 5;
                audioService.playSfx('HEAL');
                setPlayer((prev) => ({ 
                  ...prev, 
                  mp: prev.mp - 3, 
                  hp: Math.min(prev.maxHp, prev.hp + healAmount) 
                }));
                addLog(t.heal(healAmount));
              } else {
                audioService.playSfx('CANCEL');
                addLog(t.noMp);
                setBattleState(BattleState.PLAYER_INPUT); 
                return;
              }
              break;
              
            case 'ITEM':
               if (player.potions > 0) {
                  audioService.playSfx('HEAL');
                  setPlayer((prev) => ({ 
                      ...prev, 
                      potions: prev.potions - 1, 
                      hp: Math.min(prev.maxHp, prev.hp + 40) 
                  }));
                  addLog(t.itemUsed());
               } else {
                   audioService.playSfx('CANCEL');
                   addLog(t.noItem);
                   setBattleState(BattleState.PLAYER_INPUT);
                   return;
               }
               break;

            case 'FLEE':
              if (enemy.isBoss) {
                  audioService.playSfx('CANCEL');
                  addLog(t.runFail); 
              } else if (Math.random() > 0.4) {
                audioService.playSfx('CONFIRM');
                addLog(t.runSuccess);
                await new Promise(r => setTimeout(r, 1000));
                setGameState(prevGameState);
                setInputCooldown(true);
                setTimeout(() => setInputCooldown(false), 500);
                return;
              } else {
                audioService.playSfx('CANCEL');
                addLog(t.runFail);
              }
              break;
          }

          if (enemy.hp - playerDamage <= 0 && (action === 'PHYSICAL' || action === 'MAG_ATK')) {
            // EXP reduced to 2/3
            const expGain = Math.floor((enemy.maxHp * 2) * 0.66);
            const goldGain = enemy.attack * 5;
            
            const lootRoll = Math.random();
            let lootMsg = "";
            
            let newPlayer = { ...player };
            if (action === 'MAG_ATK') newPlayer.mp -= 5; 

            newPlayer.exp += expGain;
            newPlayer.gold += goldGain;
            
            let leveledUp = false;
            let nextLevelCost = newPlayer.level * 50;

            while (newPlayer.exp >= nextLevelCost) {
                newPlayer.exp -= nextLevelCost; 
                newPlayer.level += 1;
                newPlayer.maxHp += 10;
                newPlayer.maxMp += 5;
                newPlayer.hp = newPlayer.maxHp; 
                newPlayer.mp = newPlayer.maxMp;
                
                nextLevelCost = newPlayer.level * 50;
                leveledUp = true;
            }

            if (lootRoll > 0.90) { 
               const grimoires = LOOT_NAMES[lang].grimoires;
               const gName = grimoires[Math.floor(Math.random() * grimoires.length)];
               const boost = 5;
               newPlayer.maxMp += boost;
               newPlayer.mp = newPlayer.maxMp;
               lootMsg = `${t.loot.found(gName)} ${t.loot.learn("Max MP", boost)}`;
            } else if (lootRoll > 0.75) { 
               if (Math.random() > 0.5) {
                   const weapons = LOOT_NAMES[lang].weapons;
                   const wName = weapons[Math.floor(Math.random() * weapons.length)];
                   const boost = Math.floor(Math.random() * 3) + 1;
                   newPlayer.equipmentAtk += boost;
                   lootMsg = `${t.loot.found(wName)} ${t.loot.equip(t.atk, boost)}`;
               } else {
                   const armors = LOOT_NAMES[lang].armors;
                   const aName = armors[Math.floor(Math.random() * armors.length)];
                   const boost = Math.floor(Math.random() * 3) + 1;
                   newPlayer.equipmentDef += boost;
                   lootMsg = `${t.loot.found(aName)} ${t.loot.equip(t.def, boost)}`;
               }
            } else if (lootRoll > 0.40) { 
                newPlayer.potions += 1;
                lootMsg = t.loot.found(t.potions);
            }

            if (enemy.isBoss) {
                addLog(t.dungeon.floorCleared);
                
                const progressUpdate = {...dungeonProgress};
                let triggerReincarnation = false;

                if (currentScene === 'AVONLEA') {
                    if (dungeonFloor === 1) progressUpdate.avonlea.b1 = true;
                    if (dungeonFloor === 2) progressUpdate.avonlea.b2 = true;
                } else if (currentScene === 'CAVENDISH') {
                    if (dungeonFloor === 1) progressUpdate.cavendish.b1 = true;
                    if (dungeonFloor === 2) progressUpdate.cavendish.b2 = true;
                } else if (currentScene === 'CHARLOTTETOWN') {
                    if (dungeonFloor === 1) progressUpdate.charlottetown.b1 = true;
                    if (dungeonFloor === 2) {
                        progressUpdate.charlottetown.b2 = true;
                        triggerReincarnation = true;
                    }
                }
                
                setDungeonProgress(progressUpdate);

                let unlocked = false;
                if (currentScene === 'AVONLEA' && progressUpdate.avonlea.b2) unlocked = true;
                if (currentScene === 'CAVENDISH' && progressUpdate.cavendish.b2) unlocked = true;
                
                if (unlocked) {
                    addLog(t.dungeon.sceneUnlocked);
                    setTimeout(() => audioService.playSfx('WIN'), 800);
                }

                if (triggerReincarnation) {
                   const nextCount = newPlayer.reincarnationCount + 1;
                   newPlayer.reincarnationCount = nextCount;
                   newPlayer.equipmentAtk += 10;
                   newPlayer.equipmentDef += 10;
                   
                   setPendingReincarnationPlayer(newPlayer);
                   setPlayer(newPlayer); 
                   setShowReincarnationModal(true);
                   
                   if (leveledUp) {
                      addLog(`Level Up! You are now level ${newPlayer.level}!`);
                      setTimeout(() => audioService.playSfx('WIN'), 500);
                  } else {
                      audioService.playSfx('WIN');
                  }
                  addLog(t.win(expGain, goldGain));
                  if (lootMsg) addLog(lootMsg);
                  
                  setBattleState(BattleState.VICTORY);
                  return;
                }
            }

            setPlayer(newPlayer); 
            
            if (leveledUp) {
                addLog(`Level Up! You are now level ${newPlayer.level}!`);
                setTimeout(() => audioService.playSfx('WIN'), 500);
            } else {
                audioService.playSfx('WIN');
            }

            addLog(t.win(expGain, goldGain));
            if (lootMsg) addLog(lootMsg);

            setBattleState(BattleState.VICTORY);
            
            autoSaveGame(newPlayer);
            setNotification(t.saveLoad.autoSavedLog);
            setTimeout(() => setNotification(""), 2000);

            return; 
          }

          await new Promise(r => setTimeout(r, 1000));

          if (enemy.hp > 0) {
            const playerDef = 5 + Math.floor(player.level / 2) + player.equipmentDef;
            const enemyDmg = Math.max(1, enemy.attack - playerDef);
            
            audioService.playSfx('ATTACK');
            setTimeout(() => audioService.playSfx('HIT'), 200);
            
            setPlayer((prev) => ({ ...prev, hp: Math.max(0, prev.hp - enemyDmg) }));
            addLog(t.enemyAttack(enemy.name, enemyDmg));

            if (player.hp - enemyDmg <= 0) {
              audioService.playSfx('LOSE');
              addLog(t.lose);
              setBattleState(BattleState.DEFEAT);
            } else {
              setBattleState(BattleState.PLAYER_INPUT);
            }
          }
        };

        const confirmReincarnation = () => {
          if (!pendingReincarnationPlayer) return;

          audioService.playSfx('WIN');
          
          setPlayer(pendingReincarnationPlayer);

          const resetProgress = {
             avonlea: { b1: false, b2: false },
             cavendish: { b1: false, b2: false },
             charlottetown: { b1: false, b2: false }
          };
          setDungeonProgress(resetProgress);
          
          setCurrentScene('AVONLEA');
          setGameState(GameState.MAP);
          setPlayerPos(MAP_START_POS);
          
          autoSaveGame(pendingReincarnationPlayer);
          
          setShowReincarnationModal(false);
          setPendingReincarnationPlayer(null);
        };

        const handleShopTransaction = (choice) => {
          if (choice === 1) {
              setActiveShop(null);
              setTownMessage("");
              return;
          }

          const costRest = 20;
          const costWeapon = 100 * player.level;
          const costArmor = 100 * player.level;
          const costPotion = 20;
          const costMagic = 200 * player.level;

          let success = false;

          if (activeShop === 'GUILD') {
              if (player.gold >= costRest) {
                  setPlayer((p) => ({...p, gold: p.gold - costRest, hp: p.maxHp, mp: p.maxMp}));
                  setTownMessage(t.town.restored);
                  success = true;
              }
          } else if (activeShop === 'WEAPON') {
              if (player.gold >= costWeapon) {
                  setPlayer((p) => ({...p, gold: p.gold - costWeapon, equipmentAtk: p.equipmentAtk + 3}));
                  setTownMessage(t.town.bought);
                  success = true;
              }
          } else if (activeShop === 'ARMOR') {
              if (player.gold >= costArmor) {
                  setPlayer((p) => ({...p, gold: p.gold - costArmor, equipmentDef: p.equipmentDef + 3}));
                  setTownMessage(t.town.bought);
                  success = true;
              }
          } else if (activeShop === 'ITEM') {
              if (player.gold >= costPotion) {
                  setPlayer((p) => ({...p, gold: p.gold - costPotion, potions: p.potions + 1}));
                  setTownMessage(t.town.bought);
                  success = true;
              }
          } else if (activeShop === 'MAGIC') {
              if (player.gold >= costMagic) {
                  setPlayer((p) => ({...p, gold: p.gold - costMagic, maxMp: p.maxMp + 5, mp: p.mp + 5}));
                  setTownMessage(t.town.bought);
                  success = true;
              }
          }

          if (success) audioService.playSfx('HEAL'); 
          else {
              setTownMessage(t.town.notEnoughGold);
              audioService.playSfx('CANCEL');
          }
        };

        const switchScene = (target) => {
            audioService.playSfx('CONFIRM');
            setCurrentScene(target);
            setPlayerPos(MAP_START_POS);
            const targetName = target === 'AVONLEA' ? t.scenes.avonlea : (target === 'CAVENDISH' ? t.scenes.cavendish : t.scenes.charlottetown);
            setMapMessage(t.scenes.travelTo(targetName));
        };

        const handleInput = useCallback((key) => {
          if (loading || showSaveMenu || showLoadMenu || notification || inputCooldown || showReincarnationModal || showAboutModal || showApiKeyModal) return;

          if (gameState === GameState.NAME_INPUT) {
              if (key === 'ENTER') submitName();
              return;
          }

          if (gameState !== GameState.MAP && gameState !== GameState.TOWN && gameState !== GameState.DUNGEON && (key === 'UP' || key === 'DOWN')) audioService.playSfx('SELECT');

          if (gameState === GameState.TITLE) {
            if (key === 'UP') setTitleSelection(prev => (prev - 1 + 3) % 3);
            if (key === 'DOWN') setTitleSelection(prev => (prev + 1) % 3);
            if (key === 'ENTER') {
               audioService.playSfx('CONFIRM');
               if (titleSelection === 0) {
                  setPlayerNameInput("");
                  setGameState(GameState.NAME_INPUT);
               } else if (titleSelection === 1) {
                   if (hasSaves) {
                      setShowLoadMenu(true);
                   } else {
                       audioService.playSfx('CANCEL');
                   }
               } else if (titleSelection === 2) {
                   setShowApiKeyModal(true);
               }
            }
          } 
          else if (gameState === GameState.MAP) {
            const MAP_DATA = getCurrentMapData();
            
            if (key === 'ENTER') {
                const tile = MAP_DATA[playerPos.y][playerPos.x];
                
                if (tile === 'C') {
                    audioService.playSfx('CONFIRM');
                    setSelectedLocation('castle');
                    setGameState(GameState.TOWN);
                    setTownMessage(t.town.welcome);
                    setTownPlayerPos(TOWN_START_POS); 
                    setActiveShop(null);
                    initTownNPCs(); 
                } else if (tile === 'V') {
                    audioService.playSfx('CONFIRM');
                    setSelectedLocation('volcano');
                    setGameState(GameState.DUNGEON);
                    setDungeonFloor(1); 
                    setDungeonPlayerPos(DUNGEON_START_POS);
                    setExploreLog(t.dungeon.floor(1));
                    setMenuIndex(0);
                } else if (tile === 'H') {
                    audioService.playSfx('HEAL');
                    setMapMessage(t.facilityHints.house);
                } else if (tile === 'K') {
                    audioService.playSfx('CONFIRM');
                    setMapMessage(t.facilityHints.school);
                } else if (tile === 'U') {
                    audioService.playSfx('CONFIRM');
                    setMapMessage(t.facilityHints.academy);
                } else {
                    setMapMessage(t.dungeon.nothing);
                }
                return;
            }

            let dx = 0;
            let dy = 0;
            if (key === 'UP') dy = -1;
            if (key === 'DOWN') dy = 1;
            if (key === 'LEFT') dx = -1;
            if (key === 'RIGHT') dx = 1;

            const newX = playerPos.x + dx;
            const newY = playerPos.y + dy;

            if (newY >= 0 && newY < MAP_DATA.length && newX >= 0 && newX < MAP_DATA[0].length) {
                const targetTile = MAP_DATA[newY][newX];
                if (targetTile !== 'W') {
                    setPlayerPos({ x: newX, y: newY });
                    audioService.playSfx('SELECT');
                    
                    if (targetTile === 'C') setMapMessage(t.mapActions.enterTown);
                    else if (targetTile === 'V') setMapMessage(t.mapActions.enterDungeon);
                    else if (targetTile === 'H') setMapMessage(t.facilityHints.house);
                    else if (targetTile === 'K') setMapMessage(t.facilityHints.school);
                    else if (targetTile === 'U') setMapMessage(t.facilityHints.academy);
                    else setMapMessage("");

                    if (targetTile !== 'C' && targetTile !== 'V' && targetTile !== 'H' && targetTile !== 'K' && targetTile !== 'U') {
                        checkRandomEncounter(targetTile);
                    }
                }
            }
          }
          else if (gameState === GameState.TOWN) {
              if (activeShop) {
                  if (key === 'UP') setMenuIndex(prev => (prev - 1 + 2) % 2);
                  if (key === 'DOWN') setMenuIndex(prev => (prev + 1) % 2);
                  if (key === 'ENTER') handleShopTransaction(menuIndex);
              } else {
                  if (key === 'ENTER') {
                      const tile = TOWN_MAP[townPlayerPos.y][townPlayerPos.x];
                      
                      if (tile === 'E') {
                          audioService.playSfx('CANCEL');
                          setGameState(GameState.MAP);
                          return;
                      }

                      const npc = townNPCs.find(n => getDist({x: n.x, y: n.y}, townPlayerPos) <= 1);
                      
                      if (npc) {
                          audioService.playSfx('CONFIRM');
                          let msg = `[${npc.name}]: ${npc.dialogue}`;
                          
                          if (npc.reward && !npc.rewardClaimed) {
                              const r = npc.reward;
                              if (r.type === 'GOLD') {
                                  setPlayer((p) => ({...p, gold: p.gold + r.value}));
                                  msg += ` (ç²å¾— ${r.value} é‡‘å¹£)`;
                              } else if (r.type === 'POTION') {
                                  setPlayer((p) => ({...p, potions: p.potions + r.value}));
                                  msg += ` (ç²å¾— ${r.value} è—¥æ°´)`;
                              } else if (r.type === 'MAXHP') {
                                  setPlayer((p) => ({...p, maxHp: p.maxHp + r.value, hp: p.hp + r.value}));
                                  msg += ` (ç”Ÿå‘½ä¸Šé™ +${r.value})`;
                              } else if (r.type === 'MAXMP') {
                                  setPlayer((p) => ({...p, maxMp: p.maxMp + r.value, mp: p.mp + r.value}));
                                  msg += ` (é­”åŠ›ä¸Šé™ +${r.value})`;
                              }
                              audioService.playSfx('WIN'); 
                              setTownNPCs(prev => prev.map(n => n.id === npc.id ? {...n, rewardClaimed: true} : n));
                          }
                          setTownMessage(msg);
                          return; 
                      }

                      let shop = null;
                      if (tile === 'g') shop = 'GUILD';
                      else if (tile === 'w') shop = 'WEAPON';
                      else if (tile === 'a') shop = 'ARMOR';
                      else if (tile === 'i') shop = 'ITEM';
                      else if (tile === 'm') shop = 'MAGIC';

                      if (shop) {
                          audioService.playSfx('CONFIRM');
                          setActiveShop(shop);
                          setTownMessage("");
                          setMenuIndex(0);
                      }
                      return;
                  }

                  let dx = 0;
                  let dy = 0;
                  if (key === 'UP') dy = -1;
                  if (key === 'DOWN') dy = 1;
                  if (key === 'LEFT') dx = -1;
                  if (key === 'RIGHT') dx = 1;

                  const newX = townPlayerPos.x + dx;
                  const newY = townPlayerPos.y + dy;

                  if (newY >= 0 && newY < TOWN_MAP.length && newX >= 0 && newX < TOWN_MAP[0].length) {
                      const targetTile = TOWN_MAP[newY][newX];
                      if (targetTile !== 'T' && targetTile !== 'N' && targetTile !== '_') {
                          setTownPlayerPos({ x: newX, y: newY });
                          audioService.playSfx('SELECT');
                          
                          let msg = "";
                          if (targetTile === 'g') msg = t.town.shops.guild;
                          if (targetTile === 'w') msg = t.town.shops.weapon;
                          if (targetTile === 'a') msg = t.town.shops.armor;
                          if (targetTile === 'i') msg = t.town.shops.item;
                          if (targetTile === 'm') msg = t.town.shops.magic;
                          if (targetTile === 'E') msg = t.town.exitTown;
                          if (msg) setTownMessage(t.town.enterShop); 
                      }
                  }
              }
          }
          else if (gameState === GameState.DUNGEON) {
              const dMap = getDungeonMap();
              
              if (key === 'ENTER') {
                  const tile = dMap[dungeonPlayerPos.y][dungeonPlayerPos.x];
                  
                  let cleared = false;
                  if (currentScene === 'AVONLEA') {
                      cleared = dungeonFloor === 1 ? dungeonProgress.avonlea.b1 : dungeonProgress.avonlea.b2;
                  } else if (currentScene === 'CAVENDISH') {
                      cleared = dungeonFloor === 1 ? dungeonProgress.cavendish.b1 : dungeonProgress.cavendish.b2;
                  } else if (currentScene === 'CHARLOTTETOWN') {
                      cleared = dungeonFloor === 1 ? dungeonProgress.charlottetown.b1 : dungeonProgress.charlottetown.b2;
                  }

                  if (tile === 'E') {
                      audioService.playSfx('CONFIRM');
                      setGameState(GameState.MAP);
                      setExploreLog("");
                  } else if (tile === 'S') {
                      audioService.playSfx('CONFIRM');
                      if (dungeonFloor === 1) {
                          setDungeonFloor(2);
                          setDungeonPlayerPos({x: 12, y: 1}); 
                          setExploreLog(t.dungeon.floor(2));
                      } else {
                          setDungeonFloor(1);
                          setDungeonPlayerPos({x: 12, y: 1}); 
                          setExploreLog(t.dungeon.floor(1));
                      }
                  } else if (tile === 'B') {
                      if (!cleared) {
                           setExploreLog(t.dungeon.bossEncounter);
                           setTimeout(() => startBattle(true), 200);
                      } else {
                          audioService.playSfx('CONFIRM');
                          if (dungeonFloor === 1) {
                              setDungeonFloor(2);
                              setDungeonPlayerPos({x: 12, y: 1}); 
                              setExploreLog(t.dungeon.floor(2));
                          } else {
                              setGameState(GameState.MAP);
                              setExploreLog("");
                          }
                      }
                  }
                  return;
              }

              let dx = 0;
              let dy = 0;
              if (key === 'UP') dy = -1;
              if (key === 'DOWN') dy = 1;
              if (key === 'LEFT') dx = -1;
              if (key === 'RIGHT') dx = 1;

              const newX = dungeonPlayerPos.x + dx;
              const newY = dungeonPlayerPos.y + dy;

              if (newY >= 0 && newY < dMap.length && newX >= 0 && newX < dMap[0].length) {
                  const targetTile = dMap[newY][newX];
                  if (targetTile !== 'd' && targetTile !== '_') {
                      setDungeonPlayerPos({ x: newX, y: newY });
                      audioService.playSfx('SELECT');
                      
                      if (targetTile !== 'E' && targetTile !== 'S' && targetTile !== 'B') {
                          checkRandomEncounter(targetTile);
                      }

                      if (targetTile === 'E') setExploreLog(t.dungeon.leave);
                      else if (targetTile === 'B') setExploreLog(t.dungeon.bossEncounter);
                      else if (targetTile === 'S') setExploreLog(dungeonFloor === 1 ? t.dungeon.goDeeper : t.dungeon.returnSurface);
                      else setExploreLog(t.dungeon.search);
                  }
              }
          }
          else if (gameState === GameState.BATTLE && battleState === BattleState.PLAYER_INPUT) {
            const actions = ['PHYSICAL', 'MAG_ATK', 'MAG_HEAL', 'ITEM', 'FLEE'];
            if (key === 'UP') setMenuIndex(prev => (prev - 1 + 5) % 5);
            if (key === 'DOWN') setMenuIndex(prev => (prev + 1) % 5);
            if (key === 'ENTER') {
              handlePlayerAction(actions[menuIndex]);
            }
          }
          else if ((battleState === BattleState.VICTORY || battleState === BattleState.DEFEAT) && key === 'ENTER') {
              audioService.playSfx('CONFIRM');
              
              setBattleState(BattleState.PLAYER_INPUT);

              if (battleState === BattleState.VICTORY) {
                  if (prevGameState === GameState.MAP || prevGameState === GameState.DUNGEON) {
                       setGameState(prevGameState);
                  } else {
                       setGameState(GameState.MAP); 
                  }
                  setInputCooldown(true);
                  setTimeout(() => setInputCooldown(false), 500);
                  setMenuIndex(0);
              } else {
                  setPlayer((prev) => {
                      const penalty = Math.floor((prev.level * 50) * 0.1);
                      const currentLevelMinExp = (prev.level - 1) * 50; 
                      return {
                          ...prev,
                          hp: prev.maxHp,
                          mp: prev.maxMp,
                          exp: Math.max(currentLevelMinExp, prev.exp - penalty)
                      };
                  });
                  setGameState(GameState.TOWN);
                  setSelectedLocation('castle');
                  setTownPlayerPos(TOWN_START_POS);
                  setTownMessage(lang === Language.ZH ? "ä½ è¢«æ•‘å›äº†åŸé®ï¼Œé›–ç„¶æœ‰äº›æå¤±ï¼Œä½†å‘½ä¿ä½äº†ã€‚" : "You were revived in town. Some XP lost, but you live.");
                  setMenuIndex(0);
              }
          }
        }, [gameState, menuIndex, battleState, loading, player, enemy, lang, selectedLocation, playerPos, townPlayerPos, dungeonPlayerPos, activeShop, currentScene, dungeonFloor, dungeonProgress, showSaveMenu, showLoadMenu, playerNameInput, notification, prevGameState, inputCooldown, showReincarnationModal, pendingReincarnationPlayer, townNPCs, showAboutModal, titleSelection, hasSaves, showApiKeyModal]);

        const handleMapClick = (targetX, targetY, type) => {
            if (loading || showSaveMenu || showLoadMenu || notification || inputCooldown || showReincarnationModal || showAboutModal || showApiKeyModal) return;

            handleUserInteraction();
            let currentPos = playerPos;
            if (type === 'TOWN') currentPos = townPlayerPos;
            if (type === 'DUNGEON') currentPos = dungeonPlayerPos;

            const dx = targetX - currentPos.x;
            const dy = targetY - currentPos.y;

            if (Math.abs(dx) + Math.abs(dy) === 1) {
                if (dy === -1) handleInput('UP');
                if (dy === 1) handleInput('DOWN');
                if (dx === -1) handleInput('LEFT');
                if (dx === 1) handleInput('RIGHT');
            } else if (dx === 0 && dy === 0) {
                handleInput('ENTER');
            } else if (type === 'WORLD') {
                const MAP_DATA = getCurrentMapData();
                if (targetY >= 0 && targetY < MAP_DATA.length && targetX >= 0 && targetX < MAP_DATA[0].length) {
                   const tile = MAP_DATA[targetY][targetX];
                   audioService.playSfx('SELECT');
                   if (tile === 'H') setMapMessage(t.facilityHints.house);
                   else if (tile === 'K') setMapMessage(t.facilityHints.school);
                   else if (tile === 'U') setMapMessage(t.facilityHints.academy);
                   else if (tile === 'C') setMapMessage(t.mapActions.enterTown);
                   else if (tile === 'V') setMapMessage(t.mapActions.enterDungeon);
                }
            } else if (type === 'TOWN') {
                const tile = TOWN_MAP[targetY][targetX];
                if (['g','w','a','i','m'].includes(tile)) {
                    audioService.playSfx('SELECT');
                    let msg = "";
                    if (tile === 'g') msg = `${t.town.shops.guild}: ${t.town.actions.rest(20)}`;
                    if (tile === 'w') msg = `${t.town.shops.weapon}: ${t.town.actions.buyWeapon(100 * player.level)}`;
                    if (tile === 'a') msg = `${t.town.shops.armor}: ${t.town.actions.buyArmor(100 * player.level)}`;
                    if (tile === 'i') msg = `${t.town.shops.item}: ${t.town.actions.buyPotion(20)}`;
                    if (tile === 'm') msg = `${t.town.shops.magic}: ${t.town.actions.buyMagic(200 * player.level)}`;
                    setTownMessage(msg);
                } else if (tile === 'E') {
                    audioService.playSfx('SELECT');
                    setTownMessage(t.town.exitTown);
                }
            } else if (type === 'DUNGEON') {
                const dMap = getDungeonMap();
                let cleared = false;
                if (currentScene === 'AVONLEA') cleared = dungeonFloor === 1 ? dungeonProgress.avonlea.b1 : dungeonProgress.avonlea.b2;
                else if (currentScene === 'CAVENDISH') cleared = dungeonFloor === 1 ? dungeonProgress.cavendish.b1 : dungeonProgress.cavendish.b2;
                else if (currentScene === 'CHARLOTTETOWN') cleared = dungeonFloor === 1 ? dungeonProgress.charlottetown.b1 : dungeonProgress.charlottetown.b2;

                const tile = dMap[targetY][targetX];
                let displayTile = tile;
                if (tile === 'B' && cleared) displayTile = dungeonFloor === 1 ? 'S' : 'E';

                if (['S','E','B'].includes(displayTile)) {
                    audioService.playSfx('SELECT');
                    if (displayTile === 'E') setExploreLog(t.dungeon.leave);
                    else if (displayTile === 'B') setExploreLog(t.dungeon.bossEncounter);
                    else if (displayTile === 'S') setExploreLog(dungeonFloor === 1 ? t.dungeon.goDeeper : t.dungeon.returnSurface);
                }
            }
        };

        useEffect(() => {
          const handleKeyDown = (e) => {
            if (loading) return; 
            if (gameState === GameState.NAME_INPUT) {
                if (e.key === 'Enter') handleInput('ENTER');
                return;
            }

            if (e.key === 'ArrowUp' || e.key === 'w') handleInput('UP');
            if (e.key === 'ArrowDown' || e.key === 's') handleInput('DOWN');
            if (e.key === 'ArrowLeft' || e.key === 'a') handleInput('LEFT');
            if (e.key === 'ArrowRight' || e.key === 'd') handleInput('RIGHT');
            if (e.key === 'Enter' || e.key === ' ') handleInput('ENTER');
          };
          window.addEventListener('keydown', handleKeyDown);
          return () => window.removeEventListener('keydown', handleKeyDown);
        }, [handleInput, loading, gameState]);

        return (
          <div className="w-full h-full relative">
            <div className="scanlines"></div>
            
            {/* Global Utility Buttons (Top Right) */}
            {gameState !== GameState.TITLE && gameState !== GameState.NAME_INPUT && (
                <div className="absolute top-2 right-14 z-50 flex gap-2">
                    <button 
                        onClick={(e) => { e.stopPropagation(); setShowSaveMenu(true); audioService.playSfx('SELECT'); }}
                        className="bg-blue-900 border border-white text-white px-2 py-1 text-xs md:text-sm hover:bg-blue-700 font-bold shadow-md uppercase"
                    >
                        ğŸ’¾ {t.saveLoad.saveBtn}
                    </button>
                    <button 
                        onClick={(e) => { 
                            e.stopPropagation(); 
                            if(confirm(lang === Language.ZH ? 'ç¢ºå®šè¦è¿”å›æ¨™é¡Œç•«é¢å—ï¼Ÿæœªå„²å­˜çš„é€²åº¦å°‡æœƒéºå¤±ã€‚' : 'Return to title? Unsaved progress will be lost.')) {
                                setGameState(GameState.TITLE); 
                                audioService.playBgm('TITLE');
                            }
                        }}
                        className="bg-red-900 border border-white text-white px-2 py-1 text-xs md:text-sm hover:bg-red-700 font-bold shadow-md uppercase"
                    >
                        ğŸ  {t.saveLoad.returnTitle}
                    </button>
                </div>
            )}

            <div 
              className="absolute top-2 right-2 z-50 text-2xl cursor-pointer opacity-50 hover:opacity-100 drop-shadow-md"
              onClick={e => {
                e.stopPropagation();
                audioService.init().catch(console.error);
                const muted = audioService.toggleMute();
                setIsMuted(muted);
                if (!muted) audioService.playSfx('SELECT');
              }}
            >
              {isMuted ? 'ğŸ”‡' : 'ğŸ”Š'}
            </div>

            {gameState === GameState.TITLE && (
              <TitleScreen 
                  t={t} lang={lang} setLang={setLang} 
                  titleSelection={titleSelection} setTitleSelection={setTitleSelection} 
                  handleInput={handleInput} 
                  setShowLoadMenu={setShowLoadMenu} setShowApiKeyModal={setShowApiKeyModal} setShowAboutModal={setShowAboutModal}
                  hasSaves={hasSaves} hasApiKey={hasApiKey} audioService={audioService}
                  setGameState={setGameState} setPlayer={setPlayer} setMapMessage={setMapMessage}
              />
            )}

            {gameState === GameState.NAME_INPUT && (
                <NameInputModal 
                  playerNameInput={playerNameInput} handleNameChange={handleNameChange} submitName={submitName} t={t} 
                />
            )}

            {gameState === GameState.MAP && (
                <WorldMapScreen 
                  player={player} t={t} currentScene={currentScene} playerPos={playerPos} 
                  mapMessage={mapMessage} handleMapClick={handleMapClick} switchScene={switchScene} dungeonProgress={dungeonProgress}
                  onHeal={handleFieldHeal}
                />
            )}

            {gameState === GameState.TOWN && (
                <TownScreen 
                   player={player} t={t} townPlayerPos={townPlayerPos} townMessage={townMessage}
                   activeShop={activeShop} menuIndex={menuIndex} townNPCs={townNPCs}
                   handleShopTransaction={handleShopTransaction} handleMapClick={handleMapClick}
                   onHeal={handleFieldHeal}
                />
            )}

            {gameState === GameState.DUNGEON && (
                <DungeonScreen 
                  player={player} t={t} dungeonFloor={dungeonFloor} dungeonPlayerPos={dungeonPlayerPos}
                  dungeonProgress={dungeonProgress} exploreLog={exploreLog} currentScene={currentScene} handleMapClick={handleMapClick}
                  onHeal={handleFieldHeal}
                />
            )}

            {gameState === GameState.BATTLE && (
                <BattleScreen 
                   player={player} enemy={enemy} t={t} battleState={battleState} 
                   battleLogs={battleLogs} menuIndex={menuIndex} handlePlayerAction={handlePlayerAction}
                   selectedLocation={selectedLocation} currentScene={currentScene} dungeonFloor={dungeonFloor}
                   scrollRef={scrollRef}
                />
            )}

            {/* Overlays */}
            {notification && (
                <div className="absolute top-10 left-1/2 transform -translate-x-1/2 z-[100] animate-fade-in-up">
                    <div className="bg-blue-900/90 border-2 border-white px-6 py-2 rounded shadow-xl text-yellow-300 font-bold">
                        {notification}
                    </div>
                </div>
            )}
            
            {showSaveMenu && (
                <SaveLoadMenu 
                   showSaveMenu={showSaveMenu} setShowSaveMenu={setShowSaveMenu} setShowLoadMenu={setShowLoadMenu}
                   saveMessage={saveMessage} t={t} saveGame={saveGame} loadGame={loadGame}
                />
            )}
            
            {showLoadMenu && (
                <SaveLoadMenu 
                   showSaveMenu={showSaveMenu} setShowSaveMenu={setShowSaveMenu} setShowLoadMenu={setShowLoadMenu}
                   saveMessage={saveMessage} t={t} saveGame={saveGame} loadGame={loadGame}
                />
            )}

            <AboutModal showAboutModal={showAboutModal} setShowAboutModal={setShowAboutModal} t={t} />
            
            <ApiKeyModal 
                showApiKeyModal={showApiKeyModal} setShowApiKeyModal={setShowApiKeyModal} t={t}
                hasApiKey={hasApiKey} setHasApiKey={setHasApiKey} setNotification={setNotification} audioService={audioService}
            />
            
            <ReincarnationModal 
                showReincarnationModal={showReincarnationModal} pendingReincarnationPlayer={pendingReincarnationPlayer}
                confirmReincarnation={confirmReincarnation} t={t}
            />

            <VirtualPad 
                onUp={() => handleInput('UP')}
                onDown={() => handleInput('DOWN')}
                onSelect={() => handleInput('ENTER')}
            />
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>